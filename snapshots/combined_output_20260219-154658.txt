# Arborescence du dépôt

  - Dockerfile
  - README.md
  - docker-compose.yml
  - pyproject.toml
  - src/
    - src/azursmartmix_control/
      - __init__.py
      - api.py
      - compose_reader.py
      - config.py
      - docker_client.py
      - icecast_client.py
      - main.py
      - scheduler_client.py
      - test
      - ui.py

---


---
# docker-compose.yml
---

services:
  control:
    build: .
    image: chourmovs/azursmartmix-control:latest
    container_name: azursmartmix_control
    environment:
      # Where the scheduler API lives (inside docker network)
      SCHED_BASE_URL: "http://azursmartmix_scheduler:8001"

      # Target container names (adjust if yours differ)
      ENGINE_CONTAINER: "azursmartmix_engine"
      SCHEDULER_CONTAINER: "azursmartmix_scheduler"

      # Optional config file to expose read-only
      CONFIG_PATH: "/config/config.yml"

      # UI & API ports
      UI_HOST: "0.0.0.0"
      UI_PORT: "8088"
      API_PREFIX: "/api"

      # Logs tail limits
      LOG_TAIL_LINES_DEFAULT: "400"
      LOG_TAIL_LINES_MAX: "2000"

    ports:
      - "8088:8088"

    volumes:
      # Docker socket read-only (status + logs)
      - /var/run/docker.sock:/var/run/docker.sock:ro

      # Optional runtime config RO
      - ./config/config.yml:/config/config.yml:ro

    restart: unless-stopped


---
# pyproject.toml
---

[project]
name = "azursmartmix-control"
version = "0.1.0"
description = "AzurSmartMix Control Plane (read-only) - FastAPI + NiceGUI"
requires-python = ">=3.12"
dependencies = [
  "fastapi==0.115.6",
  "uvicorn[standard]==0.30.6",
  "nicegui==2.7.0",
  "httpx==0.27.2",
  "pydantic==2.10.2",
  "pydantic-settings==2.6.1",
  "PyYAML==6.0.2",
  "docker==7.1.0",
  "python-json-logger==2.0.7",
]

[tool.uvicorn]
factory = false


---
# src/azursmartmix_control/__init__.py
---

__all__ = ["__version__"]
__version__ = "0.1.0"


---
# src/azursmartmix_control/api.py
---

from __future__ import annotations

import os
from typing import Any, Dict, Optional

from fastapi import FastAPI, Query
from fastapi.responses import JSONResponse, PlainTextResponse

from azursmartmix_control.config import Settings
from azursmartmix_control.docker_client import DockerClient
from azursmartmix_control.scheduler_client import SchedulerClient
from azursmartmix_control.compose_reader import get_service_env
from azursmartmix_control.icecast_client import IcecastClient


def _fmt_duration(seconds: Optional[int]) -> Optional[str]:
    if seconds is None:
        return None
    s = int(seconds)
    if s < 0:
        s = 0
    d, rem = divmod(s, 86400)
    h, rem = divmod(rem, 3600)
    m, sec = divmod(rem, 60)
    if d > 0:
        return f"{d}d {h:02d}:{m:02d}:{sec:02d}"
    return f"{h:02d}:{m:02d}:{sec:02d}"


def create_api(settings: Settings) -> FastAPI:
    app = FastAPI(title="AzurSmartMix Control API", version="0.1.0")

    docker_client = DockerClient()

    now_ep = os.getenv("SCHED_NOW_ENDPOINT", "").strip() or None
    sched = SchedulerClient(settings.sched_base_url, now_endpoint=now_ep)

    ice = IcecastClient(
        scheme=settings.icecast_scheme,
        host=settings.icecast_host,
        port=settings.icecast_port,
        status_path=settings.icecast_status_path,
        mount=settings.icecast_mount,
    )

    @app.get("/health")
    def health() -> Dict[str, Any]:
        return {"ok": True}

    @app.get("/status")
    def status() -> Dict[str, Any]:
        return docker_client.runtime_summary(settings.engine_container, settings.scheduler_container)

    @app.get("/logs", response_class=PlainTextResponse)
    def logs(
        service: str = Query(..., description="engine|scheduler|<container_name>"),
        tail: int = Query(0, description="lines to tail (0 = default)"),
    ) -> str:
        tail_eff = tail if tail > 0 else settings.log_tail_lines_default
        tail_eff = max(1, min(tail_eff, settings.log_tail_lines_max))

        if service == "engine":
            name = settings.engine_container
        elif service == "scheduler":
            name = settings.scheduler_container
        else:
            name = service

        return docker_client.tail_logs(name=name, tail=tail_eff)

    # --- scheduler proxy (still useful for /next) ---
    @app.get("/scheduler/upcoming")
    async def scheduler_upcoming(n: int = Query(10, ge=1, le=50)) -> JSONResponse:
        data = await sched.upcoming(n=n)
        return JSONResponse(data)

    # --- compose env (your "config") ---
    @app.get("/panel/engine_env")
    def panel_engine_env() -> Dict[str, Any]:
        return get_service_env(settings.compose_path, settings.compose_service_engine)

    # --- panel runtime ---
    @app.get("/panel/runtime")
    def panel_runtime() -> Dict[str, Any]:
        raw = docker_client.runtime_summary(settings.engine_container, settings.scheduler_container)

        eng = raw.get("engine") or {}
        sch = raw.get("scheduler") or {}

        def pack(x: Dict[str, Any]) -> Dict[str, Any]:
            if not x.get("present"):
                return {"present": False, "name": x.get("name"), "status": "missing"}
            return {
                "present": True,
                "name": x.get("name"),
                "image": x.get("image"),
                "status": x.get("status"),
                "health": x.get("health"),
                "uptime": _fmt_duration(x.get("uptime_s")),
                "age": _fmt_duration(x.get("age_s")),
            }

        return {
            "now_utc": raw.get("now_utc"),
            "docker_ping": raw.get("docker_ping"),
            "engine": pack(eng),
            "scheduler": pack(sch),
        }

    # --- panel now (title only) ---
    @app.get("/panel/now")
    async def panel_now() -> Dict[str, Any]:
        ic = await ice.now_playing()
        title = None
        if isinstance(ic, dict) and ic.get("ok"):
            title = ic.get("title") or (ic.get("raw") or {}).get("title")
        return {"ok": bool(title), "title": title, "source": "icecast", "mount": settings.icecast_mount}

    # --- panel upcoming (clean titles from preprocess log) ---
    @app.get("/panel/upcoming")
    async def panel_upcoming(n: int = Query(10, ge=1, le=30)) -> Dict[str, Any]:
        ic = await ice.now_playing()
        current_title = None
        if isinstance(ic, dict) and ic.get("ok"):
            current_title = ic.get("title")

        upcoming = docker_client.compute_upcoming_from_preprocess(
            engine_container=settings.engine_container,
            current_title=current_title,
            n=n,
            tail=2500,
        )
        return upcoming

    return app


---
# src/azursmartmix_control/compose_reader.py
---

from __future__ import annotations

import os
from typing import Any, Dict, List, Optional, Tuple, Union

import yaml


def _as_kv(item: Any) -> Optional[Tuple[str, str]]:
    """Convert docker-compose environment entries to (key, value).

    Supports:
    - ["A=1", "B=2"]
    - {"A": "1", "B": 2}
    - ["A"] (means inherited/empty -> we keep empty string)
    """
    if isinstance(item, str):
        if "=" in item:
            k, v = item.split("=", 1)
            return k.strip(), v
        return item.strip(), ""
    return None


def read_compose_services_env(compose_path: str) -> Dict[str, Any]:
    """Read compose and return service->env mapping (raw, best-effort)."""
    if not compose_path or not os.path.exists(compose_path):
        return {
            "present": False,
            "path": compose_path,
            "error": "compose file not found",
            "services": {},
        }

    try:
        with open(compose_path, "r", encoding="utf-8") as f:
            doc = yaml.safe_load(f)
    except Exception as e:
        return {
            "present": True,
            "path": compose_path,
            "error": f"failed to read/parse yaml: {e}",
            "services": {},
        }

    services = (doc or {}).get("services") or {}
    out: Dict[str, Any] = {}

    for svc_name, svc in services.items():
        env = (svc or {}).get("environment", None)
        env_out: Dict[str, str] = {}

        if isinstance(env, dict):
            for k, v in env.items():
                env_out[str(k)] = "" if v is None else str(v)
        elif isinstance(env, list):
            for it in env:
                kv = _as_kv(it)
                if kv:
                    k, v = kv
                    env_out[k] = v
        elif env is None:
            env_out = {}
        else:
            # weird type
            env_out = {"__error__": f"unsupported environment type: {type(env)}"}

        out[str(svc_name)] = {"environment": env_out}

    return {
        "present": True,
        "path": compose_path,
        "error": None,
        "services": out,
    }


def get_service_env(compose_path: str, service: str) -> Dict[str, Any]:
    """Return env vars of a specific service."""
    data = read_compose_services_env(compose_path)
    if not data.get("present"):
        return data

    services = data.get("services") or {}
    if service not in services:
        return {
            "present": True,
            "path": compose_path,
            "error": None,
            "service": service,
            "found": False,
            "environment": {},
            "available_services": sorted(list(services.keys())),
        }

    env = (services[service] or {}).get("environment") or {}
    return {
        "present": True,
        "path": compose_path,
        "error": None,
        "service": service,
        "found": True,
        "environment": env,
        "available_services": sorted(list(services.keys())),
    }


---
# src/azursmartmix_control/config.py
---

from __future__ import annotations

from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import Field


class Settings(BaseSettings):
    """Runtime settings for the control plane (v1 read-only)."""

    model_config = SettingsConfigDict(env_prefix="", extra="ignore")

    # API wiring
    api_prefix: str = Field(default="/api", alias="API_PREFIX")

    # UI bind
    ui_host: str = Field(default="0.0.0.0", alias="UI_HOST")
    ui_port: int = Field(default=8088, alias="UI_PORT")

    # Targets (Docker containers)
    engine_container: str = Field(default="azursmartmix_engine", alias="ENGINE_CONTAINER")
    scheduler_container: str = Field(default="azursmartmix_scheduler", alias="SCHEDULER_CONTAINER")

    # Scheduler API base URL
    sched_base_url: str = Field(default="http://azursmartmix_scheduler:8001", alias="SCHED_BASE_URL")

    # Compose file from AzuraMix (read-only mount)
    compose_path: str = Field(default="/compose/docker-compose.yml", alias="COMPOSE_PATH")
    compose_service_engine: str = Field(default="azursmartmix_engine", alias="COMPOSE_SERVICE_ENGINE")
    compose_service_scheduler: str = Field(default="azursmartmix_scheduler", alias="COMPOSE_SERVICE_SCHEDULER")

    # Icecast now-playing
    icecast_scheme: str = Field(default="http", alias="ICECAST_SCHEME")
    icecast_host: str = Field(default="web", alias="ICECAST_HOST")
    icecast_port: int = Field(default=8000, alias="ICECAST_PORT")
    icecast_mount: str = Field(default="/gst-test.mp3", alias="ICECAST_MOUNT")
    icecast_status_path: str = Field(default="/status-json.xsl", alias="ICECAST_STATUS_PATH")

    # Logs
    log_tail_lines_default: int = Field(default=400, alias="LOG_TAIL_LINES_DEFAULT")
    log_tail_lines_max: int = Field(default=2000, alias="LOG_TAIL_LINES_MAX")


def get_settings() -> Settings:
    return Settings()


---
# src/azursmartmix_control/docker_client.py
---

from __future__ import annotations

import datetime as dt
import os
import re
from dataclasses import dataclass
from typing import Any, Dict, List, Optional

import docker
from docker.errors import DockerException, NotFound


@dataclass(frozen=True)
class ContainerInfo:
    name: str
    id: str
    image: str
    status: str
    created_at: Optional[str]
    health: Optional[str]
    started_at: Optional[str]


class DockerClient:
    """Read-only Docker wrapper for control-plane introspection.

    v1 helpers:
    - container status summary (age/uptime)
    - parse engine logs to extract *human titles* from 'preprocess:' lines
      and compute "upcoming" after the current track (Icecast title).
    """

    _RE_PREPROCESS = re.compile(r"\bpreprocess:\s*(?P<rest>.+?)\s*$", re.IGNORECASE)
    _RE_LEADING_IDX = re.compile(r"^\s*\d+\s*[\.\)]\s*")  # "1. " or "1) "
    _RE_SAFE_ARROW = re.compile(r"\s*->\s*safe_[0-9a-f]{8,}\.wav\b", re.IGNORECASE)
    _RE_PAREN_TRAIL = re.compile(r"\s*\(.*\)\s*$")
    _RE_EXT = re.compile(r"\.(mp3|wav|flac|ogg|m4a|aac)\s*$", re.IGNORECASE)

    def __init__(self) -> None:
        self.client = docker.from_env()

    def ping(self) -> bool:
        try:
            self.client.ping()
            return True
        except DockerException:
            return False

    def get_container_info(self, name: str) -> Optional[ContainerInfo]:
        try:
            c = self.client.containers.get(name)
        except NotFound:
            return None
        except DockerException:
            return None

        attrs = getattr(c, "attrs", {}) or {}
        state = (attrs.get("State") or {})
        health = None
        if isinstance(state.get("Health"), dict):
            health = state["Health"].get("Status")

        created = attrs.get("Created")
        started = state.get("StartedAt")
        image = ""
        try:
            image = (attrs.get("Config") or {}).get("Image") or ""
        except Exception:
            image = ""

        return ContainerInfo(
            name=name,
            id=c.id[:12],
            image=image,
            status=getattr(c, "status", "unknown"),
            created_at=created,
            health=health,
            started_at=started,
        )

    def tail_logs(self, name: str, tail: int = 300) -> str:
        """Return last N lines of container logs (best-effort)."""
        try:
            c = self.client.containers.get(name)
            raw: bytes = c.logs(tail=tail, timestamps=True)  # type: ignore[assignment]
            return raw.decode("utf-8", errors="replace")
        except NotFound:
            return f"[control] container not found: {name}\n"
        except DockerException as e:
            return f"[control] docker error: {e}\n"
        except Exception as e:
            return f"[control] unexpected error: {e}\n"

    def runtime_summary(self, engine_name: str, sched_name: str) -> Dict[str, Any]:
        now = dt.datetime.now(dt.timezone.utc)
        return {
            "now_utc": now.isoformat(),
            "docker_ping": self.ping(),
            "engine": self._container_info_dict(engine_name, now),
            "scheduler": self._container_info_dict(sched_name, now),
        }

    def _container_info_dict(self, name: str, now: dt.datetime) -> Dict[str, Any]:
        info = self.get_container_info(name)
        if not info:
            return {"name": name, "present": False}

        created_dt = self._parse_docker_ts(info.created_at)
        started_dt = self._parse_docker_ts(info.started_at)

        age_s = int((now - created_dt).total_seconds()) if created_dt else None
        uptime_s = int((now - started_dt).total_seconds()) if started_dt else None

        return {
            "present": True,
            "name": info.name,
            "id": info.id,
            "image": info.image,
            "status": info.status,
            "health": info.health,
            "created_at": info.created_at,
            "started_at": info.started_at,
            "age_s": age_s,
            "uptime_s": uptime_s,
        }

    @staticmethod
    def _parse_docker_ts(ts: Optional[str]) -> Optional[dt.datetime]:
        if not ts:
            return None
        try:
            if ts.endswith("Z"):
                ts = ts[:-1] + "+00:00"
            if "." in ts:
                head, tail = ts.split(".", 1)
                frac = re.findall(r"^\d+", tail)
                if frac:
                    frac_digits = frac[0][:6].ljust(6, "0")
                    rest = tail[len(frac[0]) :]
                    ts = f"{head}.{frac_digits}{rest}"
            return dt.datetime.fromisoformat(ts)
        except Exception:
            return None

    @staticmethod
    def _dedupe_keep_order(items: List[str]) -> List[str]:
        seen = set()
        out: List[str] = []
        for x in items:
            if x in seen:
                continue
            seen.add(x)
            out.append(x)
        return out

    def _clean_preprocess_title(self, rest: str) -> Optional[str]:
        """Convert 'preprocess:' payload into a clean 'Artist - Title' string.

        Input examples:
          "1. Daddy Freddy & Tenor Fly - Go Freddy Go.mp3 -> safe_xxx.wav (silence=... LUFS ...)"
          "derrick_howard_-_behold_i_live_[1973].mp3 -> safe_....wav (...)"

        Output:
          "Daddy Freddy & Tenor Fly - Go Freddy Go"
          "derrick howard - behold i live [1973]" (underscores -> spaces)
        """
        s = (rest or "").strip()
        if not s:
            return None

        # Remove leading index "1. "
        s = self._RE_LEADING_IDX.sub("", s).strip()

        # If it contains "-> safe_xxx.wav", keep only left side
        if "->" in s:
            left = s.split("->", 1)[0].strip()
            s = left

        # Remove trailing parenthetical leftovers (just in case)
        s = self._RE_PAREN_TRAIL.sub("", s).strip()

        # Keep basename if it's a path
        s = os.path.basename(s)

        # Remove extension
        s = self._RE_EXT.sub("", s).strip()

        # Normalize underscores to spaces
        s = s.replace("_-_", " - ")
        s = s.replace("_", " ")
        s = re.sub(r"\s+", " ", s).strip()

        # If still empty, drop
        return s or None

    def extract_preprocess_titles(self, engine_container: str, tail: int = 2500) -> Dict[str, Any]:
        """Extract cleaned titles from engine logs 'preprocess:' lines."""
        txt = self.tail_logs(engine_container, tail=tail)
        if not txt or txt.startswith("[control]"):
            return {
                "ok": False,
                "source": "engine_logs",
                "engine_container": engine_container,
                "error": txt.strip() if txt else "empty logs",
                "titles": [],
            }

        titles: List[str] = []
        for line in txt.splitlines():
            m = self._RE_PREPROCESS.search(line)
            if not m:
                continue
            rest = (m.group("rest") or "").strip()
            t = self._clean_preprocess_title(rest)
            if t:
                titles.append(t)

        return {
            "ok": True,
            "source": "engine_logs",
            "engine_container": engine_container,
            "titles": titles,
            "count": len(titles),
        }

    def compute_upcoming_from_preprocess(
        self,
        engine_container: str,
        current_title: Optional[str],
        n: int = 10,
        tail: int = 2500,
    ) -> Dict[str, Any]:
        """Compute upcoming titles from preprocess logs after current_title.

        - Find LAST occurrence of current_title in the cleaned preprocess sequence
        - Return the next unique titles (keep order) limited to n
        - If not found: fallback to last chunk as "best effort"
        """
        data = self.extract_preprocess_titles(engine_container, tail=tail)
        if not data.get("ok"):
            return {"ok": False, "error": data.get("error"), "upcoming": [], "source": "engine_logs"}

        titles = data.get("titles") or []
        titles = [t for t in titles if isinstance(t, str) and t.strip()]
        if not titles:
            return {"ok": False, "error": "no preprocess titles found", "upcoming": [], "source": "engine_logs"}

        cur = (current_title or "").strip()
        start_idx = None

        if cur:
            for i in range(len(titles) - 1, -1, -1):
                if titles[i].strip() == cur:
                    start_idx = i + 1
                    break

        if start_idx is None:
            chunk = titles[-(n * 4) :]
            chunk = self._dedupe_keep_order(chunk)
            return {
                "ok": True,
                "source": "engine_logs_fallback_tail",
                "current_title_found": False,
                "current_title": current_title,
                "upcoming": chunk[:n],
            }

        chunk2 = titles[start_idx:]
        chunk2 = self._dedupe_keep_order(chunk2)
        return {
            "ok": True,
            "source": "engine_logs_after_current",
            "current_title_found": True,
            "current_title": current_title,
            "upcoming": chunk2[:n],
        }


---
# src/azursmartmix_control/icecast_client.py
---

from __future__ import annotations

from typing import Any, Dict, Optional

import httpx


class IcecastClient:
    """Read-only Icecast status client (best-effort).

    Default endpoint: /status-json.xsl
    We extract the source matching the configured mount and return:
    - title (if present)
    - artist (if present)
    - listeners, bitrate, server_name, etc. when available
    """

    def __init__(self, scheme: str, host: str, port: int, status_path: str, mount: str) -> None:
        self.scheme = scheme or "http"
        self.host = host
        self.port = int(port)
        self.status_path = status_path or "/status-json.xsl"
        self.mount = mount if mount.startswith("/") else f"/{mount}"
        self.timeout = httpx.Timeout(2.5, connect=1.5)

    def _base(self) -> str:
        return f"{self.scheme}://{self.host}:{self.port}"

    async def fetch_status(self) -> Dict[str, Any]:
        url = f"{self._base()}{self.status_path}"
        async with httpx.AsyncClient(timeout=self.timeout) as client:
            r = await client.get(url)
            r.raise_for_status()
            # Icecast status-json is usually JSON despite .xsl
            try:
                return r.json()
            except Exception:
                return {"raw_text": r.text}

    @staticmethod
    def _iter_sources(payload: Dict[str, Any]):
        icestats = (payload or {}).get("icestats") or {}
        src = icestats.get("source")
        if src is None:
            return []
        if isinstance(src, list):
            return src
        return [src] if isinstance(src, dict) else []

    async def now_playing(self) -> Dict[str, Any]:
        try:
            payload = await self.fetch_status()
        except Exception as e:
            return {
                "ok": False,
                "source": "icecast",
                "error": str(e),
                "mount": self.mount,
            }

        sources = self._iter_sources(payload)
        match = None
        for s in sources:
            # Icecast uses "listenurl" and/or "mount" depending on version/config
            mount = s.get("mount") or None
            if mount is None:
                listenurl = s.get("listenurl") or ""
                if listenurl.endswith(self.mount):
                    match = s
                    break
            else:
                if str(mount) == self.mount:
                    match = s
                    break

        if match is None:
            return {
                "ok": False,
                "source": "icecast",
                "error": "mount not found in status",
                "mount": self.mount,
                "available": [
                    (s.get("mount") or s.get("listenurl") or "unknown") for s in sources
                ],
            }

        # "title" is what many sources set (often "Artist - Track")
        title = match.get("title") or match.get("yp_currently_playing") or None
        artist = match.get("artist") or None

        return {
            "ok": True,
            "source": "icecast",
            "mount": self.mount,
            "title": title,
            "artist": artist,
            "listeners": match.get("listeners"),
            "listener_peak": match.get("listener_peak"),
            "bitrate": match.get("bitrate"),
            "server_name": match.get("server_name"),
            "genre": match.get("genre"),
            "raw": match,
        }


---
# src/azursmartmix_control/main.py
---

from __future__ import annotations

import logging

from pythonjsonlogger import jsonlogger
from fastapi import FastAPI
from nicegui import app, ui

from azursmartmix_control.config import get_settings
from azursmartmix_control.api import create_api
from azursmartmix_control.ui import ControlUI


def setup_logging() -> None:
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    handler = logging.StreamHandler()
    formatter = jsonlogger.JsonFormatter("%(asctime)s %(levelname)s %(name)s %(message)s")
    handler.setFormatter(formatter)
    logger.handlers = [handler]


def main() -> int:
    setup_logging()
    settings = get_settings()

    api_app: FastAPI = create_api(settings)

    # Mount FastAPI under /api so NiceGUI and API share one server/port
    app.mount(settings.api_prefix, api_app)

    # Build NiceGUI UI
    ui_builder = ControlUI(settings)
    ui_builder.build()

    ui.run(
        host=settings.ui_host,
        port=settings.ui_port,
        reload=False,
        title="AzurSmartMix Control",
        show=False,
    )
    return 0


if __name__ == "__main__":
    raise SystemExit(main())


---
# src/azursmartmix_control/scheduler_client.py
---

from __future__ import annotations

from typing import Any, Dict, Optional

import httpx


class SchedulerClient:
    """Proxy client to AzurSmartMix scheduler API.

    v1: scheduler has /health and /next.
    Now-playing endpoints are NOT assumed to exist.
    If you later add one, set env SCHED_NOW_ENDPOINT (e.g. "/now").
    """

    def __init__(self, base_url: str, now_endpoint: Optional[str] = None) -> None:
        self.base_url = base_url.rstrip("/")
        self.timeout = httpx.Timeout(2.5, connect=1.5)
        self.now_endpoint = (now_endpoint or "").strip() or None

    async def health(self) -> Dict[str, Any]:
        async with httpx.AsyncClient(timeout=self.timeout) as client:
            r = await client.get(f"{self.base_url}/health")
            r.raise_for_status()
            data = self._safe_json(r)
            return data if isinstance(data, dict) else {"ok": True, "raw": data}

    async def now_playing(self) -> Dict[str, Any]:
        """Now playing via scheduler IF configured.

        By default returns a note (no probes, no log spam).
        """
        if not self.now_endpoint:
            return {
                "source": None,
                "data": {"note": "Scheduler now-playing endpoint not configured (v1)."},
            }

        data = await self._try_get_json(self.now_endpoint)
        if data is None:
            return {
                "source": self.now_endpoint,
                "data": {"note": "Configured scheduler now endpoint returned error/404."},
            }
        return {"source": self.now_endpoint, "data": data}

    async def upcoming(self, n: int = 10) -> Dict[str, Any]:
        """Best-effort upcoming queue."""
        # Prefer /next?n=...
        data = await self._try_get_json(f"/next?n={n}")
        if data is not None:
            return {"source": f"/next?n={n}", "data": data}

        # Fallback /next10 style
        data = await self._try_get_json(f"/next{n}")
        if data is not None:
            return {"source": f"/next{n}", "data": data}

        # Minimal fallback /next1
        data = await self._try_get_json("/next1")
        if data is not None:
            return {"source": "/next1", "data": data}

        return {"source": None, "data": {"note": "No upcoming endpoint found on scheduler."}}

    async def _try_get_json(self, path: str) -> Optional[Any]:
        p = path if path.startswith("/") else f"/{path}"
        async with httpx.AsyncClient(timeout=self.timeout) as client:
            try:
                r = await client.get(f"{self.base_url}{p}")
                if r.status_code >= 400:
                    return None
                return self._safe_json(r)
            except Exception:
                return None

    @staticmethod
    def _safe_json(r: httpx.Response) -> Any:
        ct = (r.headers.get("content-type") or "").lower()
        if "application/json" in ct:
            try:
                return r.json()
            except Exception:
                return {"raw_text": r.text}
        txt = r.text.strip()
        return {"raw_text": txt} if txt else {}


---
# src/azursmartmix_control/ui.py
---

from __future__ import annotations

from typing import Any, Dict, List, Tuple

import html
import re

import httpx
from nicegui import ui

from azursmartmix_control.config import Settings


AZURA_CSS = r"""
:root{
  --az-blue: #1e88e5;
  --az-blue-dark: #1565c0;
  --az-bg: #1f242d;
  --az-card: #262c37;
  --az-card2: #2b3340;
  --az-border: rgba(255,255,255,.08);
  --az-text: rgba(255,255,255,.92);
  --az-muted: rgba(255,255,255,.65);
  --az-green: #22c55e;
  --az-red: #ef4444;
  --az-orange: #f59e0b;
  --az-cyan: #22d3ee;
  --az-violet: #a78bfa;
  --az-shadow: 0 10px 30px rgba(0,0,0,.25);
  --az-radius: 10px;
  --az-font: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif;
  --az-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  --wrap-max: 1860px;
  --grid-gap: 18px;
}

html, body { background: var(--az-bg) !important; color: var(--az-text) !important; font-family: var(--az-font) !important; }
.q-page-container, .q-layout, .q-page { background: var(--az-bg) !important; }
.q-card, .q-table__container, .q-menu, .q-dialog__inner, .q-drawer { background: transparent !important; }

.az-topbar{
  background: linear-gradient(0deg, var(--az-blue) 0%, var(--az-blue-dark) 100%) !important;
  color: white !important;
  border-bottom: 1px solid rgba(255,255,255,.15);
  box-shadow: var(--az-shadow);
}
.az-topbar .az-brand { font-weight: 900; }
.az-topbar .az-sub { opacity: .85; font-weight: 600; }

.az-wrap{ width:100%; max-width: var(--wrap-max); margin: 0 auto; padding: 18px 18px 28px 18px; }
.az-grid{ display:grid; grid-template-columns: 1fr 1fr; gap: var(--grid-gap); }
@media (max-width: 1200px){ .az-grid{ grid-template-columns: 1fr; } }

.az-card{
  background: var(--az-card) !important;
  border: 1px solid var(--az-border);
  border-radius: var(--az-radius);
  box-shadow: var(--az-shadow);
  overflow: hidden;
  min-width: 520px;
}
@media (max-width: 1200px){ .az-card{ min-width: unset; } }

.az-card-h{
  background: var(--az-blue) !important;
  color: white !important;
  padding: 12px 14px;
  font-weight: 900;
  display:flex; align-items:center; justify-content:space-between;
}
.az-card-b{ padding: 14px; background: linear-gradient(180deg, var(--az-card2), var(--az-card)); }

.az-badge{
  display:inline-flex; align-items:center; gap:8px;
  padding:6px 10px; border-radius:999px;
  font-weight:900; font-size:12px;
  border:1px solid var(--az-border);
  background: rgba(255,255,255,.05);
}
.az-dot{ width:10px; height:10px; border-radius:999px; display:inline-block; }
.az-dot.ok{ background: var(--az-green); }
.az-dot.err{ background: var(--az-red); }
.az-dot.warn{ background: var(--az-orange); }

.az-actions .q-btn{ border-radius: 10px !important; font-weight: 900 !important; text-transform:none !important; }
.az-actions .q-btn--outline{ border:1px solid rgba(255,255,255,.55) !important; color:white !important; }

.az-list{ display:flex; flex-direction:column; gap:8px; }
.az-item{ padding: 10px 12px; border-radius: 10px; border: 1px solid var(--az-border); background: rgba(255,255,255,.04); }
.az-item .idx{ display:inline-block; min-width:24px; font-weight:950; color: rgba(255,255,255,.75); }
.az-item .txt{ font-weight:650; }

/* ===== Runtime tables ===== */
.rt-grid{ display:grid; grid-template-columns: 1fr 1fr; gap: 14px; }
@media (max-width: 900px){ .rt-grid{ grid-template-columns: 1fr; } }

.rt-box{
  border: 1px solid var(--az-border);
  border-radius: 10px;
  background: rgba(0,0,0,.10);
  overflow: hidden;
}
.rt-box-h{
  padding: 10px 12px;
  font-weight: 900;
  border-bottom: 1px solid rgba(255,255,255,.08);
  color: rgba(255,255,255,.92);
}
.rt-table{ width: 100%; border-collapse: collapse; font-size: 13px; }
.rt-table tr td{
  padding: 8px 12px;
  border-bottom: 1px solid rgba(255,255,255,.06);
  vertical-align: top;
}
.rt-table tr:last-child td{ border-bottom: none; }
.rt-k{ width: 140px; color: var(--az-muted); }
.rt-v{ color: rgba(255,255,255,.92); font-family: var(--az-mono); word-break: break-word; }

/* ===== Engine env viewer ===== */
.env-toolbar{ display:flex; gap:10px; align-items:center; margin-bottom: 10px; }
.env-search input{ font-family: var(--az-mono) !important; }
.env-frame{
  max-height: 360px;
  overflow-y: auto;
  padding-right: 6px;
  border: 1px solid var(--az-border);
  border-radius: 10px;
  background: rgba(0,0,0,.12);
}
.env-row{
  display:grid;
  grid-template-columns: 260px 1fr;
  gap: 10px;
  padding: 8px 10px;
  border-bottom: 1px solid rgba(255,255,255,.06);
}
.env-row:last-child{ border-bottom: none; }
.env-k{
  font-family: var(--az-mono);
  font-size: 12px;
  color: rgba(255,255,255,.80);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.env-v{
  font-family: var(--az-mono);
  font-size: 12px;
  color: rgba(255,255,255,.92);
  word-break: break-word;
}
.env-row:hover{ background: rgba(255,255,255,.05); }

.env-frame::-webkit-scrollbar{ width: 10px; }
.env-frame::-webkit-scrollbar-track{ background: rgba(255,255,255,.06); border-radius: 10px; }
.env-frame::-webkit-scrollbar-thumb{ background: rgba(255,255,255,.22); border-radius: 10px; }
.env-frame::-webkit-scrollbar-thumb:hover{ background: rgba(255,255,255,.34); }

/* ===== Console viewer (HTML <pre>) ===== */
.console-frame{
  height: 420px;
  overflow: auto;
  border: 1px solid var(--az-border);
  border-radius: 10px;
  background: rgba(0,0,0,.22);
  padding: 10px 12px;
}
.console-pre{
  margin: 0;
  font-family: var(--az-mono);
  font-size: 12px;
  line-height: 1.35;
  color: rgba(255,255,255,.86);
  white-space: pre-wrap;
  word-break: break-word;
}

/* tokens */
.t-dim{ color: rgba(255,255,255,.45); }
.t-info{ color: rgba(56, 189, 248, .95); }   /* sky */
.t-warn{ color: rgba(245, 158, 11, .95); }   /* orange */
.t-err{  color: rgba(239, 68, 68, .95); }    /* red */
.t-ok{   color: rgba(34, 197, 94, .95); }    /* green */
.t-vio{  color: rgba(167, 139, 250, .95); }  /* violet */
.t-cyan{ color: rgba(34, 211, 238, .95); }   /* cyan */
.t-bold{ font-weight: 900; }
"""

AZURA_JS = r"""
document.addEventListener('click', (ev) => {
  const el = ev.target.closest('[data-copy]');
  if (!el) return;
  const txt = el.getAttribute('data-copy') || el.textContent || '';
  if (!txt) return;
  navigator.clipboard.writeText(txt).catch(()=>{});
});
"""


class ControlUI:
    def __init__(self, settings: Settings) -> None:
        self.settings = settings
        self.api_base = settings.api_prefix.rstrip("/")
        self.timeout = httpx.Timeout(2.5, connect=1.5)
        self._timer = None

        self._docker_badge = None
        self._rt_engine_tbl = None
        self._rt_sched_tbl = None

        self._now_title = None
        self._up_list_container = None

        self._env_search = None
        self._env_frame = None
        self._env_rows: List[Tuple[str, str]] = []

        # logs
        self._log_html_engine = None
        self._log_html_sched = None

    def build(self) -> None:
        ui.add_head_html(f"<style>{AZURA_CSS}</style>")
        ui.add_head_html(f"<script>{AZURA_JS}</script>")
        ui.page_title("AzurSmartMix Control")

        with ui.header().classes("az-topbar items-center justify-between"):
            with ui.row().classes("items-center gap-3"):
                ui.label("azuracast").classes("az-brand text-xl")
                ui.label("AzurSmartMix Control").classes("az-sub text-sm")
            with ui.row().classes("items-center gap-2 az-actions"):
                ui.button("Refresh", on_click=self.refresh_all).props("unelevated color=white text-color=primary")
                ui.button("Auto 5s", on_click=self.enable_autorefresh).props("outline")
                ui.button("Stop", on_click=self.disable_autorefresh).props("outline")

        with ui.element("div").classes("az-wrap"):
            with ui.element("div").classes("az-grid"):
                self._card_runtime()
                self._card_env()
                self._card_now()
                self._card_upcoming()

            with ui.element("div").classes("az-grid").style("margin-top: 16px;"):
                self._card_logs()

        ui.timer(0.1, self.refresh_all, once=True)

    # ---------- Cards ----------

    def _card_runtime(self) -> None:
        with ui.element("div").classes("az-card"):
            with ui.element("div").classes("az-card-h"):
                ui.label("Runtime Status")
                self._docker_badge = ui.html(
                    '<span class="az-badge"><span class="az-dot warn"></span><span>Docker: …</span></span>'
                )
            with ui.element("div").classes("az-card-b"):
                with ui.element("div").classes("rt-grid"):
                    self._rt_engine_tbl = self._runtime_box("Engine")
                    self._rt_sched_tbl = self._runtime_box("Scheduler")

    def _runtime_box(self, title: str):
        with ui.element("div").classes("rt-box"):
            ui.label(title).classes("rt-box-h")
            tbl = ui.html(self._runtime_table_html({}))
            return tbl

    def _runtime_table_html(self, data: Dict[str, Any]) -> str:
        def v(key: str, default: str = "—") -> str:
            raw = data.get(key)
            if raw is None or raw == "":
                raw = default
            return html.escape(str(raw))

        rows = [
            ("name", v("name")),
            ("image", v("image")),
            ("status", v("status")),
            ("health", v("health", "-")),
            ("uptime", v("uptime", "-")),
        ]
        tr = "".join(
            f'<tr><td class="rt-k">{html.escape(k)}</td><td class="rt-v" data-copy="{val}">{val}</td></tr>'
            for k, val in rows
        )
        return f'<table class="rt-table">{tr}</table>'

    def _card_env(self) -> None:
        with ui.element("div").classes("az-card"):
            with ui.element("div").classes("az-card-h"):
                ui.label("Engine env (docker-compose)")
                ui.label(self.settings.compose_service_engine).classes("text-xs").style("opacity:.85;")
            with ui.element("div").classes("az-card-b"):
                with ui.element("div").classes("env-toolbar"):
                    self._env_search = ui.input(placeholder="Filter (key/value)…").classes("env-search").props("dense outlined")
                    ui.button("Clear", on_click=self._env_clear_filter).props("outline")
                self._env_frame = ui.element("div").classes("env-frame")

    def _card_now(self) -> None:
        with ui.element("div").classes("az-card"):
            with ui.element("div").classes("az-card-h"):
                ui.label("Now Playing")
                ui.label(self.settings.icecast_mount).classes("text-xs").style("opacity:.85;")
            with ui.element("div").classes("az-card-b"):
                self._now_title = ui.label("—").classes("text-xl").style("font-weight: 950; margin: 2px 0 6px 0;")
                ui.label("Icecast metadata (title only)").style("font-size: 12px; opacity:.7;")

    def _card_upcoming(self) -> None:
        with ui.element("div").classes("az-card"):
            with ui.element("div").classes("az-card-h"):
                ui.label("Upcoming")
                ui.label("from engine preprocess log").classes("text-xs").style("opacity:.85;")
            with ui.element("div").classes("az-card-b"):
                self._up_list_container = ui.element("div").classes("az-list")

    def _card_logs(self) -> None:
        with ui.element("div").classes("az-card").style("grid-column: 1 / -1;"):
            with ui.element("div").classes("az-card-h"):
                ui.label("Logs")
                ui.label("tail=200").classes("text-xs").style("opacity:.85;")
            with ui.element("div").classes("az-card-b"):
                tabs = ui.tabs().classes("w-full")
                t_engine = ui.tab("engine")
                t_sched = ui.tab("scheduler")
                with ui.tab_panels(tabs, value=t_engine).classes("w-full"):
                    with ui.tab_panel(t_engine):
                        with ui.element("div").classes("console-frame"):
                            self._log_html_engine = ui.html('<pre class="console-pre">—</pre>')
                    with ui.tab_panel(t_sched):
                        with ui.element("div").classes("console-frame"):
                            self._log_html_sched = ui.html('<pre class="console-pre">—</pre>')

    # ---------- HTTP helpers ----------

    async def _get_json(self, path: str) -> Dict[str, Any]:
        url = f"http://127.0.0.1:{self.settings.ui_port}{self.api_base}{path}"
        async with httpx.AsyncClient(timeout=self.timeout) as client:
            r = await client.get(url)
            r.raise_for_status()
            data = r.json()
            return data if isinstance(data, dict) else {"data": data}

    async def _get_text(self, path: str) -> str:
        url = f"http://127.0.0.1:{self.settings.ui_port}{self.api_base}{path}"
        async with httpx.AsyncClient(timeout=self.timeout) as client:
            r = await client.get(url)
            r.raise_for_status()
            return r.text

    # ---------- Log highlight ----------

    _re_level = re.compile(r"\b(INFO|WARN|WARNING|ERROR|CRITICAL|DEBUG)\b")
    _re_engine_tag = re.compile(r"\bazurmixd\.engine\b")
    _re_sched_tag = re.compile(r"\bazurmixd\.scheduler\b")
    _re_preprocess = re.compile(r"\bpreprocess:\b")
    _re_bridge = re.compile(r"\bbridgeplan:\b")
    _re_aft = re.compile(r"\bAFT#\d+\b")
    _re_icecast = re.compile(r"\b(Icecast|ICECAST|/status-json\.xsl|mount|listeners?)\b", re.IGNORECASE)
    _re_uri = re.compile(r"\b(file:///[^ ]+)\b")

    def _highlight_logs_html(self, text: str) -> str:
        # escape first to prevent HTML injection, then do safe replacements
        esc = html.escape(text)

        def repl_level(m: re.Match) -> str:
            lvl = m.group(1)
            cls = "t-info"
            if lvl in ("WARN", "WARNING"):
                cls = "t-warn"
            elif lvl in ("ERROR", "CRITICAL"):
                cls = "t-err"
            elif lvl == "DEBUG":
                cls = "t-dim"
            return f'<span class="{cls} t-bold">{lvl}</span>'

        esc = self._re_level.sub(repl_level, esc)
        esc = self._re_engine_tag.sub(r'<span class="t-cyan t-bold">azurmixd.engine</span>', esc)
        esc = self._re_sched_tag.sub(r'<span class="t-cyan t-bold">azurmixd.scheduler</span>', esc)
        esc = self._re_preprocess.sub(r'<span class="t-vio t-bold">preprocess:</span>', esc)
        esc = self._re_bridge.sub(r'<span class="t-vio">bridgeplan:</span>', esc)
        esc = self._re_aft.sub(lambda m: f'<span class="t-ok t-bold">{m.group(0)}</span>', esc)
        esc = self._re_icecast.sub(lambda m: f'<span class="t-cyan">{m.group(0)}</span>', esc)
        esc = self._re_uri.sub(r'<span class="t-dim">\1</span>', esc)

        return f'<pre class="console-pre">{esc}</pre>'

    # ---------- Refresh ----------

    async def refresh_all(self) -> None:
        await self.refresh_runtime()
        await self.refresh_engine_env()
        await self.refresh_now()
        await self.refresh_upcoming()
        await self.refresh_logs()

    async def refresh_runtime(self) -> None:
        try:
            rt = await self._get_json("/panel/runtime")
        except Exception:
            self._set_docker_badge(ok=False, text="Docker: error")
            if self._rt_engine_tbl:
                self._rt_engine_tbl.set_content(self._runtime_table_html({"status": "error"}))
            if self._rt_sched_tbl:
                self._rt_sched_tbl.set_content(self._runtime_table_html({"status": "error"}))
            return

        docker_ok = bool(rt.get("docker_ping"))
        self._set_docker_badge(ok=docker_ok, text=f"Docker: {'OK' if docker_ok else 'DOWN'}")

        eng = rt.get("engine") or {}
        sch = rt.get("scheduler") or {}

        if self._rt_engine_tbl:
            self._rt_engine_tbl.set_content(self._runtime_table_html(eng))
        if self._rt_sched_tbl:
            self._rt_sched_tbl.set_content(self._runtime_table_html(sch))

    def _set_docker_badge(self, ok: bool, text: str) -> None:
        if self._docker_badge is None:
            return
        dot = "ok" if ok else "err"
        self._docker_badge.set_content(
            f'<span class="az-badge"><span class="az-dot {dot}"></span><span>{html.escape(text)}</span></span>'
        )

    async def refresh_engine_env(self) -> None:
        if self._env_frame is None:
            return
        try:
            data = await self._get_json("/panel/engine_env")
            env = data.get("environment") if isinstance(data, dict) else None
            if isinstance(env, dict):
                self._env_rows = [(k, str(env.get(k, ""))) for k in sorted(env.keys())]
            else:
                self._env_rows = [("error", str(data))]
        except Exception as e:
            self._env_rows = [("error", str(e))]
        self._render_env()

    def _env_clear_filter(self) -> None:
        if self._env_search:
            self._env_search.set_value("")
        self._render_env()

    def _render_env(self) -> None:
        if self._env_frame is None:
            return
        q = ""
        if self._env_search:
            q = (self._env_search.value or "").strip().lower()

        rows = self._env_rows
        if q:
            rows = [(k, v) for (k, v) in rows if q in k.lower() or q in v.lower()]

        self._env_frame.clear()
        with self._env_frame:
            if not rows:
                ui.html('<div style="padding:10px; opacity:.7;">—</div>')
                return
            for k, v in rows:
                k_e = html.escape(k)
                v_e = html.escape(v)
                ui.html(
                    f'<div class="env-row">'
                    f'  <div class="env-k" data-copy="{k_e}">{k_e}</div>'
                    f'  <div class="env-v" data-copy="{v_e}">{v_e}</div>'
                    f'</div>'
                )

    async def refresh_now(self) -> None:
        try:
            now = await self._get_json("/panel/now")
            self._now_title.set_text(now.get("title") or "—")
        except Exception:
            self._now_title.set_text("—")

    async def refresh_upcoming(self) -> None:
        if self._up_list_container is None:
            return
        try:
            up = await self._get_json("/panel/upcoming?n=10")
            titles = up.get("upcoming") or []
            if not isinstance(titles, list):
                titles = []
        except Exception:
            titles = []

        self._up_list_container.clear()
        with self._up_list_container:
            if not titles:
                ui.html('<div style="opacity:.7; font-size: 12px;">—</div>')
                return
            for i, t in enumerate(titles, start=1):
                t_safe = html.escape(str(t))
                ui.html(
                    f'<div class="az-item"><span class="idx">{i}.</span> '
                    f'<span class="txt" data-copy="{t_safe}">{t_safe}</span></div>'
                )

    async def refresh_logs(self) -> None:
        # engine
        try:
            eng = await self._get_text("/logs?service=engine&tail=200")
            if self._log_html_engine:
                self._log_html_engine.set_content(self._highlight_logs_html(eng))
        except Exception:
            if self._log_html_engine:
                self._log_html_engine.set_content('<pre class="console-pre">—</pre>')

        # scheduler
        try:
            sch = await self._get_text("/logs?service=scheduler&tail=200")
            if self._log_html_sched:
                self._log_html_sched.set_content(self._highlight_logs_html(sch))
        except Exception:
            if self._log_html_sched:
                self._log_html_sched.set_content('<pre class="console-pre">—</pre>')

    def enable_autorefresh(self) -> None:
        if self._timer is not None:
            return
        self._timer = ui.timer(5.0, self.refresh_all)

    def disable_autorefresh(self) -> None:
        if self._timer is not None:
            self._timer.cancel()
        self._timer = None


---
# Estimation du nombre de tokens : 12258 tokens
