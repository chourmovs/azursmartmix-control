# Arborescence du dépôt

  - Dockerfile
  - README.md
  - docker-compose.yml
  - pyproject.toml
  - src/
    - src/azursmartmix_control/
      - __init__.py
      - api.py
      - compose_reader.py
      - config.py
      - docker_client.py
      - icecast_client.py
      - main.py
      - scheduler_client.py
      - test
      - ui.py

---


---
# docker-compose.yml
---

services:
  control:
    image: chourmovs/azursmartmix-control:latest
    container_name: azursmartmix_control
    environment:
      SCHED_BASE_URL: "http://azursmartmix_scheduler:8001"
      ENGINE_CONTAINER: "azursmartmix_engine"
      SCHEDULER_CONTAINER: "azursmartmix_scheduler"
      UI_HOST: "0.0.0.0"
      UI_PORT: "8088"
      API_PREFIX: "/api"
      LOG_TAIL_LINES_DEFAULT: "400"
      LOG_TAIL_LINES_MAX: "2000"

      COMPOSE_PATH: "/compose/docker-compose.yml"
      COMPOSE_SERVICE_ENGINE: "azursmartmix_engine"
      COMPOSE_SERVICE_SCHEDULER: "azursmartmix_scheduler"
      
      ICECAST_PUBLIC_URL: "http://chourmovs.ddnsfree.com:8000/gst-test.mp3"
      ICECAST_HOST: "web"
      ICECAST_PORT: "8000"
      ICECAST_MOUNT: "/gst-test.mp3"
      ICECAST_SCHEME: "http"
      ICECAST_STATUS_PATH: "/status-json.xsl"

    ports:
      - "8088:8088"

    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
      - ./config/config.yml:/config/config.yml:ro
      - ../docker-compose.yml:/compose/docker-compose.yml:ro

    networks:
      - azursmartmix_net

    restart: unless-stopped

networks:
  azursmartmix_net:
    external: true
    name: azuracast_default


---
# pyproject.toml
---

[project]
name = "azursmartmix-control"
version = "0.1.0"
description = "AzurSmartMix Control Plane (read-only) - FastAPI + NiceGUI"
requires-python = ">=3.12"
dependencies = [
  "fastapi==0.115.6",
  "uvicorn[standard]==0.30.6",
  "nicegui==2.7.0",
  "httpx==0.27.2",
  "pydantic==2.10.2",
  "pydantic-settings==2.6.1",
  "PyYAML==6.0.2",
  "docker==7.1.0",
  "python-json-logger==2.0.7",
]

[tool.uvicorn]
factory = false


---
# src/azursmartmix_control/__init__.py
---

__all__ = ["__version__"]
__version__ = "0.1.0"


---
# src/azursmartmix_control/api.py
---

from __future__ import annotations

import os
from typing import Any, Dict, List, Optional

from fastapi import FastAPI, Query
from fastapi.responses import JSONResponse, PlainTextResponse

from azursmartmix_control.config import Settings
from azursmartmix_control.docker_client import DockerClient
from azursmartmix_control.scheduler_client import SchedulerClient
from azursmartmix_control.compose_reader import get_service_env
from azursmartmix_control.icecast_client import IcecastClient


def _fmt_duration(seconds: Optional[int]) -> Optional[str]:
    if seconds is None:
        return None
    s = int(seconds)
    if s < 0:
        s = 0
    d, rem = divmod(s, 86400)
    h, rem = divmod(rem, 3600)
    m, sec = divmod(rem, 60)
    if d > 0:
        return f"{d}d {h:02d}:{m:02d}:{sec:02d}"
    return f"{h:02d}:{m:02d}:{sec:02d}"


def create_api(settings: Settings) -> FastAPI:
    app = FastAPI(title="AzurSmartMix Control API", version="0.1.0")

    docker_client = DockerClient()

    now_ep = os.getenv("SCHED_NOW_ENDPOINT", "").strip() or None
    sched = SchedulerClient(settings.sched_base_url, now_endpoint=now_ep)

    ice = IcecastClient(
        scheme=settings.icecast_scheme,
        host=settings.icecast_host,
        port=settings.icecast_port,
        status_path=settings.icecast_status_path,
        mount=settings.icecast_mount,
    )

    @app.get("/health")
    def health() -> Dict[str, Any]:
        return {"ok": True}

    @app.get("/status")
    def status() -> Dict[str, Any]:
        return docker_client.runtime_summary(settings.engine_container, settings.scheduler_container)

    @app.get("/logs", response_class=PlainTextResponse)
    def logs(
        service: str = Query(..., description="engine|scheduler|<container_name>"),
        tail: int = Query(0, description="lines to tail (0 = default)"),
    ) -> str:
        tail_eff = tail if tail > 0 else settings.log_tail_lines_default
        tail_eff = max(1, min(tail_eff, settings.log_tail_lines_max))

        if service == "engine":
            name = settings.engine_container
        elif service == "scheduler":
            name = settings.scheduler_container
        else:
            name = service

        return docker_client.tail_logs(name=name, tail=tail_eff)

    @app.get("/scheduler/upcoming")
    async def scheduler_upcoming(n: int = Query(10, ge=1, le=50)) -> JSONResponse:
        data = await sched.upcoming(n=n)
        return JSONResponse(data)

    @app.get("/panel/engine_env")
    def panel_engine_env() -> Dict[str, Any]:
        return get_service_env(settings.compose_path, settings.compose_service_engine)

    @app.get("/panel/runtime")
    def panel_runtime() -> Dict[str, Any]:
        raw = docker_client.runtime_summary(settings.engine_container, settings.scheduler_container)

        eng = raw.get("engine") or {}
        sch = raw.get("scheduler") or {}

        def pack(x: Dict[str, Any]) -> Dict[str, Any]:
            if not x.get("present"):
                return {"present": False, "name": x.get("name"), "status": "missing"}
            return {
                "present": True,
                "name": x.get("name"),
                "image": x.get("image"),
                "status": x.get("status"),
                "health": x.get("health"),
                "uptime": _fmt_duration(x.get("uptime_s")),
                "age": _fmt_duration(x.get("age_s")),
            }

        return {
            "now_utc": raw.get("now_utc"),
            "docker_ping": raw.get("docker_ping"),
            "engine": pack(eng),
            "scheduler": pack(sch),
        }

    def _compute_effective_now_and_upcoming(
        title_observed: Optional[str],
        upcoming_sched: Dict[str, Any],
    ) -> Dict[str, Any]:
        """
        Fix 1-track lag:
        - Icecast observed title may be behind.
        - Scheduler NEXT list often contains the *real* current track as first item.
        Rule:
        - If upcoming[0] exists AND it does not match observed (normalized),
          promote upcoming[0] as effective now, and upcoming list starts at upcoming[1].
        """
        observed_norm = docker_client.normalize_title(title_observed or "")
        upcoming_list = []
        if isinstance(upcoming_sched, dict) and upcoming_sched.get("ok"):
            u = upcoming_sched.get("upcoming") or []
            if isinstance(u, list):
                upcoming_list = [x for x in u if isinstance(x, dict)]

        effective_now = None
        effective_upcoming = upcoming_list

        if upcoming_list:
            first = upcoming_list[0]
            first_title_raw = str(first.get("title") or "")
            first_norm = docker_client.normalize_title(first_title_raw)

            # Promote if observed is empty OR observed != first upcoming (normalized)
            if (not observed_norm) or (first_norm and first_norm != observed_norm):
                effective_now = first
                effective_upcoming = upcoming_list[1:]

        return {
            "observed_norm": observed_norm,
            "effective_now": effective_now,
            "effective_upcoming": effective_upcoming,
            "raw_upcoming": upcoming_list,
        }

    @app.get("/panel/now")
    async def panel_now() -> Dict[str, Any]:
        # 1) observed title from Icecast (can lag)
        ic = await ice.now_playing()
        title_observed = None
        if isinstance(ic, dict) and ic.get("ok"):
            title_observed = ic.get("title") or (ic.get("raw") or {}).get("title")

        # 2) scheduler upcoming (title+playlist) computed relative to observed
        upcoming_sched = docker_client.compute_upcoming_from_scheduler_next(
            scheduler_container=settings.scheduler_container,
            current_title=title_observed,
            n=12,
            tail=3000,
        )

        # 3) engine STREAM_START hint (kept for debugging/UI hinting)
        ss = docker_client.last_engine_stream_start(
            engine_container=settings.engine_container,
            tail=1000,
            recent_window_s=12,
        )

        # 4) observed playlist inference (best-effort)
        pl_observed = docker_client.infer_playlist_for_title_from_scheduler(
            scheduler_container=settings.scheduler_container,
            current_title=title_observed,
            tail=3000,
        )
        playlist_observed = pl_observed.get("playlist") if isinstance(pl_observed, dict) else None

        # 5) effective-now fix (promote upcoming[0] if Icecast lags)
        eff = _compute_effective_now_and_upcoming(title_observed, upcoming_sched)
        effective_now = eff.get("effective_now")

        now_mode = "observed"
        title_effective = title_observed
        playlist_effective = playlist_observed

        predicted_next = None
        if effective_now and isinstance(effective_now, dict):
            # effective_now becomes authoritative for what user hears *now*
            title_effective = effective_now.get("title_display") or docker_client.display_title(str(effective_now.get("title") or ""))
            playlist_effective = effective_now.get("playlist") or playlist_effective
            now_mode = "promoted_from_upcoming"

            # predicted next becomes the first item of effective_upcoming (if any)
            effective_upcoming = eff.get("effective_upcoming") or []
            if isinstance(effective_upcoming, list) and effective_upcoming:
                predicted_next = effective_upcoming[0]
        else:
            # No promotion happened; predicted next is first raw upcoming if present
            raw_up = eff.get("raw_upcoming") or []
            if isinstance(raw_up, list) and raw_up:
                predicted_next = raw_up[0]

        return {
            "ok": bool(title_effective),
            "mount": settings.icecast_mount,
            "source": "icecast(observed)+scheduler(NEXT)+engine(hint)",
            "now_mode": now_mode,
            "title_effective": title_effective,
            "playlist_effective": playlist_effective,
            "title_observed": title_observed,
            "playlist_observed": playlist_observed,
            "scheduler_match_observed": pl_observed.get("match") if isinstance(pl_observed, dict) else None,
            "engine_stream_start": ss,
            "predicted_next": predicted_next,
            "debug": {
                "observed_norm": eff.get("observed_norm"),
                "upcoming_primary_source": upcoming_sched.get("source") if isinstance(upcoming_sched, dict) else None,
                "upcoming_count_raw": len(eff.get("raw_upcoming") or []),
                "promoted": bool(effective_now),
            },
        }

    @app.get("/panel/upcoming")
    async def panel_upcoming(n: int = Query(10, ge=1, le=30)) -> Dict[str, Any]:
        # 1) observed title from Icecast (can lag)
        ic = await ice.now_playing()
        current_title = None
        if isinstance(ic, dict) and ic.get("ok"):
            current_title = ic.get("title")

        # 2) scheduler NEXT list (primary)
        upcoming_sched = docker_client.compute_upcoming_from_scheduler_next(
            scheduler_container=settings.scheduler_container,
            current_title=current_title,
            n=max(12, n + 2),  # ensure we have enough after promotion
            tail=3000,
        )

        # 3) apply same promotion logic so upcoming list aligns with what user hears now
        eff = _compute_effective_now_and_upcoming(current_title, upcoming_sched)
        effective_upcoming = eff.get("effective_upcoming") or []
        if not isinstance(effective_upcoming, list):
            effective_upcoming = []

        # truncate to requested n
        effective_upcoming = effective_upcoming[:n]

        # 4) Secondary debug/compat: engine preprocess (titles only)
        upcoming_engine = docker_client.compute_upcoming_from_preprocess(
            engine_container=settings.engine_container,
            current_title=current_title,
            n=n,
            tail=2500,
        )
        upcoming_titles: List[str] = []
        if isinstance(upcoming_engine, dict) and upcoming_engine.get("ok"):
            u2 = upcoming_engine.get("upcoming") or []
            if isinstance(u2, list):
                upcoming_titles = [str(x) for x in u2]

        return {
            "ok": True,
            "current_title_observed": current_title,
            "source": {
                "primary": upcoming_sched.get("source") if isinstance(upcoming_sched, dict) else None,
                "secondary": upcoming_engine.get("source") if isinstance(upcoming_engine, dict) else None,
            },
            # This is what UI should display:
            "upcoming": effective_upcoming,
            # kept for older UI/debug:
            "upcoming_titles": upcoming_titles,
            "debug": {
                "observed_norm": eff.get("observed_norm"),
                "promoted_now": eff.get("effective_now"),
                "raw_upcoming_head": (eff.get("raw_upcoming") or [])[:3],
                "scheduler": upcoming_sched,
                "engine_preprocess": upcoming_engine,
            },
        }

    return app


---
# src/azursmartmix_control/compose_reader.py
---

from __future__ import annotations

import os
from typing import Any, Dict, List, Optional, Tuple, Union

import yaml


def _as_kv(item: Any) -> Optional[Tuple[str, str]]:
    """Convert docker-compose environment entries to (key, value).

    Supports:
    - ["A=1", "B=2"]
    - {"A": "1", "B": 2}
    - ["A"] (means inherited/empty -> we keep empty string)
    """
    if isinstance(item, str):
        if "=" in item:
            k, v = item.split("=", 1)
            return k.strip(), v
        return item.strip(), ""
    return None


def read_compose_services_env(compose_path: str) -> Dict[str, Any]:
    """Read compose and return service->env mapping (raw, best-effort)."""
    if not compose_path or not os.path.exists(compose_path):
        return {
            "present": False,
            "path": compose_path,
            "error": "compose file not found",
            "services": {},
        }

    try:
        with open(compose_path, "r", encoding="utf-8") as f:
            doc = yaml.safe_load(f)
    except Exception as e:
        return {
            "present": True,
            "path": compose_path,
            "error": f"failed to read/parse yaml: {e}",
            "services": {},
        }

    services = (doc or {}).get("services") or {}
    out: Dict[str, Any] = {}

    for svc_name, svc in services.items():
        env = (svc or {}).get("environment", None)
        env_out: Dict[str, str] = {}

        if isinstance(env, dict):
            for k, v in env.items():
                env_out[str(k)] = "" if v is None else str(v)
        elif isinstance(env, list):
            for it in env:
                kv = _as_kv(it)
                if kv:
                    k, v = kv
                    env_out[k] = v
        elif env is None:
            env_out = {}
        else:
            # weird type
            env_out = {"__error__": f"unsupported environment type: {type(env)}"}

        out[str(svc_name)] = {"environment": env_out}

    return {
        "present": True,
        "path": compose_path,
        "error": None,
        "services": out,
    }


def get_service_env(compose_path: str, service: str) -> Dict[str, Any]:
    """Return env vars of a specific service."""
    data = read_compose_services_env(compose_path)
    if not data.get("present"):
        return data

    services = data.get("services") or {}
    if service not in services:
        return {
            "present": True,
            "path": compose_path,
            "error": None,
            "service": service,
            "found": False,
            "environment": {},
            "available_services": sorted(list(services.keys())),
        }

    env = (services[service] or {}).get("environment") or {}
    return {
        "present": True,
        "path": compose_path,
        "error": None,
        "service": service,
        "found": True,
        "environment": env,
        "available_services": sorted(list(services.keys())),
    }


---
# src/azursmartmix_control/config.py
---

from __future__ import annotations

from pydantic_settings import BaseSettings, SettingsConfigDict
from pydantic import Field


class Settings(BaseSettings):
    """Runtime settings for the control plane (v1 read-only)."""

    model_config = SettingsConfigDict(env_prefix="", extra="ignore")

    # API wiring
    api_prefix: str = Field(default="/api", alias="API_PREFIX")

    # UI bind
    ui_host: str = Field(default="0.0.0.0", alias="UI_HOST")
    ui_port: int = Field(default=8088, alias="UI_PORT")

    # Targets (Docker containers)
    engine_container: str = Field(default="azursmartmix_engine", alias="ENGINE_CONTAINER")
    scheduler_container: str = Field(default="azursmartmix_scheduler", alias="SCHEDULER_CONTAINER")

    # Scheduler API base URL
    sched_base_url: str = Field(default="http://azursmartmix_scheduler:8001", alias="SCHED_BASE_URL")

    # Compose file from AzuraMix (read-only mount)
    compose_path: str = Field(default="/compose/docker-compose.yml", alias="COMPOSE_PATH")
    compose_service_engine: str = Field(default="azursmartmix_engine", alias="COMPOSE_SERVICE_ENGINE")
    compose_service_scheduler: str = Field(default="azursmartmix_scheduler", alias="COMPOSE_SERVICE_SCHEDULER")

    # Icecast now-playing
    icecast_scheme: str = Field(default="http", alias="ICECAST_SCHEME")
    icecast_host: str = Field(default="web", alias="ICECAST_HOST")
    icecast_port: int = Field(default=8000, alias="ICECAST_PORT")
    icecast_mount: str = Field(default="/gst-test.mp3", alias="ICECAST_MOUNT")
    icecast_status_path: str = Field(default="/status-json.xsl", alias="ICECAST_STATUS_PATH")

    # Logs
    log_tail_lines_default: int = Field(default=400, alias="LOG_TAIL_LINES_DEFAULT")
    log_tail_lines_max: int = Field(default=2000, alias="LOG_TAIL_LINES_MAX")

    icecast_public_url: str = "http://chourmovs.ddnsfree.com:8000/gst-test.mp3"

def get_settings() -> Settings:
    return Settings()


---
# src/azursmartmix_control/docker_client.py
---

from __future__ import annotations

import datetime as dt
import os
import re
from dataclasses import dataclass
from typing import Any, Dict, List, Optional

import docker
from docker.errors import DockerException, NotFound


@dataclass(frozen=True)
class ContainerInfo:
    name: str
    id: str
    image: str
    status: str
    created_at: Optional[str]
    health: Optional[str]
    started_at: Optional[str]


@dataclass(frozen=True)
class NextEntry:
    ts_raw: str
    ts: Optional[dt.datetime]
    title_raw: str
    title_norm: str
    playlist: str


class DockerClient:
    """Read-only Docker wrapper for control-plane introspection.

    Key features:
    - Tail logs from engine/scheduler containers.
    - Parse scheduler logs for NEXT entries (title + playlist).
    - Infer 'Now Playing playlist' by matching Icecast title against scheduler NEXT title.
    - Provide engine STREAM_START hint to display 'next' without UI lag.
    """

    # --- engine preprocess lines (kept for backward compat / debug) ---
    _RE_PREPROCESS = re.compile(r"\bpreprocess:\s*(?P<rest>.+?)\s*$", re.IGNORECASE)
    _RE_LEADING_IDX = re.compile(r"^\s*\d+\s*[\.\)]\s*")  # "1. " or "1) "
    _RE_PAREN_TRAIL = re.compile(r"\s*\(.*\)\s*$")
    _RE_EXT = re.compile(r"\.(mp3|wav|flac|ogg|m4a|aac)\s*$", re.IGNORECASE)

    # --- docker timestamps prefix (when docker logs called with timestamps=True) ---
    # Example:
    # 2026-02-20T12:12:58.106123456Z 2026-02-20 12:12:58,106 INFO ...
    _RE_DOCKER_TS_PREFIX = re.compile(r"^\s*\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d+Z\s+")

    # --- scheduler NEXT parsing (robust, with optional docker timestamp prefix) ---
    # Example:
    # 2026-02-20 12:12:58,106 INFO azurmixd.scheduler - NEXT | title="vanzo_-_me_and_you" | playlist="Promotion" | ...
    _RE_SCHED_NEXT = re.compile(
        r"""(?P<ts>\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2},\d{3})\s+.*?\bazurmixd\.scheduler\b.*?\bNEXT\s*\|\s*title="(?P<title>[^"]*)"\s*\|\s*playlist="(?P<playlist>[^"]*)"""  # noqa: E501
    )

    # --- engine STREAM_START parsing (robust, with optional docker timestamp prefix) ---
    _RE_STREAM_START = re.compile(r"\bBUS\s+STREAM_START\b.*\bsrc=playbin\b", re.IGNORECASE)

    def __init__(self) -> None:
        self.client = docker.from_env()

    def ping(self) -> bool:
        try:
            self.client.ping()
            return True
        except DockerException:
            return False

    def get_container_info(self, name: str) -> Optional[ContainerInfo]:
        try:
            c = self.client.containers.get(name)
        except NotFound:
            return None
        except DockerException:
            return None

        attrs = getattr(c, "attrs", {}) or {}
        state = (attrs.get("State") or {})
        health = None
        if isinstance(state.get("Health"), dict):
            health = state["Health"].get("Status")

        created = attrs.get("Created")
        started = state.get("StartedAt")
        image = ""
        try:
            image = (attrs.get("Config") or {}).get("Image") or ""
        except Exception:
            image = ""

        return ContainerInfo(
            name=name,
            id=c.id[:12],
            image=image,
            status=getattr(c, "status", "unknown"),
            created_at=created,
            health=health,
            started_at=started,
        )

    def tail_logs(self, name: str, tail: int = 300) -> str:
        """Return last N lines of container logs (best-effort)."""
        try:
            c = self.client.containers.get(name)
            # IMPORTANT: timestamps=True adds a docker timestamp prefix.
            # We keep it because it's useful for debugging; parsers must tolerate it.
            raw: bytes = c.logs(tail=tail, timestamps=True)  # type: ignore[assignment]
            return raw.decode("utf-8", errors="replace")
        except NotFound:
            return f"[control] container not found: {name}\n"
        except DockerException as e:
            return f"[control] docker error: {e}\n"
        except Exception as e:
            return f"[control] unexpected error: {e}\n"

    def runtime_summary(self, engine_name: str, sched_name: str) -> Dict[str, Any]:
        now = dt.datetime.now(dt.timezone.utc)
        return {
            "now_utc": now.isoformat(),
            "docker_ping": self.ping(),
            "engine": self._container_info_dict(engine_name, now),
            "scheduler": self._container_info_dict(sched_name, now),
        }

    def _container_info_dict(self, name: str, now: dt.datetime) -> Dict[str, Any]:
        info = self.get_container_info(name)
        if not info:
            return {"name": name, "present": False}

        created_dt = self._parse_docker_ts(info.created_at)
        started_dt = self._parse_docker_ts(info.started_at)

        age_s = int((now - created_dt).total_seconds()) if created_dt else None
        uptime_s = int((now - started_dt).total_seconds()) if started_dt else None

        return {
            "present": True,
            "name": info.name,
            "id": info.id,
            "image": info.image,
            "status": info.status,
            "health": info.health,
            "created_at": info.created_at,
            "started_at": info.started_at,
            "age_s": age_s,
            "uptime_s": uptime_s,
        }

    @staticmethod
    def _parse_docker_ts(ts: Optional[str]) -> Optional[dt.datetime]:
        if not ts:
            return None
        try:
            if ts.endswith("Z"):
                ts = ts[:-1] + "+00:00"
            if "." in ts:
                head, tail = ts.split(".", 1)
                frac = re.findall(r"^\d+", tail)
                if frac:
                    frac_digits = frac[0][:6].ljust(6, "0")
                    rest = tail[len(frac[0]) :]
                    ts = f"{head}.{frac_digits}{rest}"
            return dt.datetime.fromisoformat(ts)
        except Exception:
            return None

    @staticmethod
    def _parse_sched_ts(ts: str) -> Optional[dt.datetime]:
        """Parse scheduler log timestamp 'YYYY-MM-DD HH:MM:SS,mmm' as naive datetime."""
        try:
            return dt.datetime.strptime(ts, "%Y-%m-%d %H:%M:%S,%f")
        except Exception:
            return None

    @staticmethod
    def _dedupe_keep_order(items: List[str]) -> List[str]:
        seen = set()
        out: List[str] = []
        for x in items:
            if x in seen:
                continue
            seen.add(x)
            out.append(x)
        return out

    # ----------------------- Normalization helpers (scheduler ↔ icecast matching) -----------------------

    @staticmethod
    def normalize_title(s: str) -> str:
        """Normalize titles so scheduler 'vanzo_-_me_and_you' can match Icecast 'Vanzo - Me And You'."""
        if not s:
            return ""
        s = s.strip()
        s = os.path.basename(s)
        s = re.sub(r"\.(mp3|wav|flac|ogg|m4a|aac)$", "", s, flags=re.IGNORECASE)
        s = s.replace("_-_", " - ")
        s = s.replace("_", " ")
        s = re.sub(r"\s+", " ", s).strip().lower()
        return s

    @staticmethod
    def display_title(s: str) -> str:
        """Human display helper for scheduler titles (slugified or already human)."""
        if not s:
            return ""
        s = s.strip()
        s = os.path.basename(s)
        s = re.sub(r"\.(mp3|wav|flac|ogg|m4a|aac)$", "", s, flags=re.IGNORECASE)
        s = s.replace("_-_", " - ")
        s = s.replace("_", " ")
        s = re.sub(r"\s+", " ", s).strip()
        return s

    # ----------------------- Engine preprocess (compat) -----------------------

    def _clean_preprocess_title(self, rest: str) -> Optional[str]:
        """Convert 'preprocess:' payload into a clean 'Artist - Title' string."""
        s = (rest or "").strip()
        if not s:
            return None

        s = self._RE_LEADING_IDX.sub("", s).strip()

        if "->" in s:
            left = s.split("->", 1)[0].strip()
            s = left

        s = self._RE_PAREN_TRAIL.sub("", s).strip()
        s = os.path.basename(s)
        s = self._RE_EXT.sub("", s).strip()

        s = s.replace("_-_", " - ")
        s = s.replace("_", " ")
        s = re.sub(r"\s+", " ", s).strip()

        return s or None

    def extract_preprocess_titles(self, engine_container: str, tail: int = 2500) -> Dict[str, Any]:
        txt = self.tail_logs(engine_container, tail=tail)
        if not txt or txt.startswith("[control]"):
            return {
                "ok": False,
                "source": "engine_logs",
                "engine_container": engine_container,
                "error": txt.strip() if txt else "empty logs",
                "titles": [],
            }

        titles: List[str] = []
        for line in txt.splitlines():
            m = self._RE_PREPROCESS.search(line)
            if not m:
                continue
            rest = (m.group("rest") or "").strip()
            t = self._clean_preprocess_title(rest)
            if t:
                titles.append(t)

        return {
            "ok": True,
            "source": "engine_logs",
            "engine_container": engine_container,
            "titles": titles,
            "count": len(titles),
        }

    def compute_upcoming_from_preprocess(
        self,
        engine_container: str,
        current_title: Optional[str],
        n: int = 10,
        tail: int = 2500,
    ) -> Dict[str, Any]:
        data = self.extract_preprocess_titles(engine_container, tail=tail)
        if not data.get("ok"):
            return {"ok": False, "error": data.get("error"), "upcoming": [], "source": "engine_logs"}

        titles = data.get("titles") or []
        titles = [t for t in titles if isinstance(t, str) and t.strip()]
        if not titles:
            return {"ok": False, "error": "no preprocess titles found", "upcoming": [], "source": "engine_logs"}

        cur = (current_title or "").strip()
        start_idx = None

        if cur:
            for i in range(len(titles) - 1, -1, -1):
                if titles[i].strip() == cur:
                    start_idx = i + 1
                    break

        if start_idx is None:
            chunk = titles[-(n * 4) :]
            chunk = self._dedupe_keep_order(chunk)
            return {
                "ok": True,
                "source": "engine_logs_fallback_tail",
                "current_title_found": False,
                "current_title": current_title,
                "upcoming": chunk[:n],
            }

        chunk2 = titles[start_idx:]
        chunk2 = self._dedupe_keep_order(chunk2)
        return {
            "ok": True,
            "source": "engine_logs_after_current",
            "current_title_found": True,
            "current_title": current_title,
            "upcoming": chunk2[:n],
        }

    # ----------------------- Scheduler NEXT (fixed) -----------------------

    @staticmethod
    def _strip_docker_prefix(line: str) -> str:
        """Remove optional docker timestamp prefix if present."""
        return DockerClient._RE_DOCKER_TS_PREFIX.sub("", line, count=1).strip()

    def extract_scheduler_next_entries(self, scheduler_container: str, tail: int = 2500) -> Dict[str, Any]:
        txt = self.tail_logs(scheduler_container, tail=tail)
        if not txt or txt.startswith("[control]"):
            return {
                "ok": False,
                "source": "scheduler_logs",
                "scheduler_container": scheduler_container,
                "error": txt.strip() if txt else "empty logs",
                "entries": [],
            }

        entries: List[NextEntry] = []
        for raw in txt.splitlines():
            line = self._strip_docker_prefix(raw)
            m = self._RE_SCHED_NEXT.search(line)  # search, not match
            if not m:
                continue
            ts_raw = m.group("ts") or ""
            title_raw = m.group("title") or ""
            playlist = m.group("playlist") or ""
            title_norm = self.normalize_title(title_raw)
            entries.append(
                NextEntry(
                    ts_raw=ts_raw,
                    ts=self._parse_sched_ts(ts_raw),
                    title_raw=title_raw,
                    title_norm=title_norm,
                    playlist=playlist,
                )
            )

        return {
            "ok": True,
            "source": "scheduler_logs",
            "scheduler_container": scheduler_container,
            "count": len(entries),
            "entries": [
                {
                    "ts": e.ts_raw,
                    "title": e.title_raw,
                    "title_norm": e.title_norm,
                    "title_display": self.display_title(e.title_raw),
                    "playlist": e.playlist,
                }
                for e in entries
            ],
        }

    def infer_playlist_for_title_from_scheduler(
        self,
        scheduler_container: str,
        current_title: Optional[str],
        tail: int = 2500,
    ) -> Dict[str, Any]:
        cur_norm = self.normalize_title(current_title or "")
        data = self.extract_scheduler_next_entries(scheduler_container, tail=tail)
        if not data.get("ok"):
            return {"ok": False, "error": data.get("error"), "playlist": None, "match": None}

        entries = data.get("entries") or []
        if not cur_norm or not entries:
            return {"ok": True, "playlist": None, "match": None, "current_title": current_title, "current_norm": cur_norm}

        match = None
        for e in reversed(entries):
            if (e.get("title_norm") or "") == cur_norm:
                match = e
                break

        if not match:
            return {"ok": True, "playlist": None, "match": None, "current_title": current_title, "current_norm": cur_norm}

        return {
            "ok": True,
            "playlist": match.get("playlist"),
            "match": match,
            "current_title": current_title,
            "current_norm": cur_norm,
        }

    def compute_upcoming_from_scheduler_next(
        self,
        scheduler_container: str,
        current_title: Optional[str],
        n: int = 10,
        tail: int = 2500,
    ) -> Dict[str, Any]:
        cur_norm = self.normalize_title(current_title or "")
        data = self.extract_scheduler_next_entries(scheduler_container, tail=tail)
        if not data.get("ok"):
            return {"ok": False, "error": data.get("error"), "upcoming": [], "source": "scheduler_logs"}

        raw_entries = data.get("entries") or []
        if not raw_entries:
            return {"ok": False, "error": "no scheduler NEXT entries found", "upcoming": [], "source": "scheduler_logs"}

        start_idx = None
        if cur_norm:
            for i in range(len(raw_entries) - 1, -1, -1):
                if (raw_entries[i].get("title_norm") or "") == cur_norm:
                    start_idx = i + 1
                    break

        seq = raw_entries[start_idx:] if start_idx is not None else raw_entries[-(n * 8) :]

        seen: set[str] = set()
        out: List[Dict[str, Any]] = []
        for e in seq:
            tn = (e.get("title_norm") or "").strip()
            if not tn or tn in seen:
                continue
            seen.add(tn)
            out.append(
                {
                    "title": e.get("title"),
                    "title_display": e.get("title_display") or self.display_title(str(e.get("title") or "")),
                    "playlist": e.get("playlist"),
                    "ts": e.get("ts"),
                }
            )
            if len(out) >= n:
                break

        return {
            "ok": True,
            "source": "scheduler_logs_after_current" if start_idx is not None else "scheduler_logs_fallback_tail",
            "current_title_found": start_idx is not None,
            "current_title": current_title,
            "upcoming": out,
        }

    # ----------------------- Engine STREAM_START (fixed) -----------------------

    def last_engine_stream_start(
        self,
        engine_container: str,
        tail: int = 800,
        recent_window_s: int = 10,
    ) -> Dict[str, Any]:
        txt = self.tail_logs(engine_container, tail=tail)
        if not txt or txt.startswith("[control]"):
            return {
                "ok": False,
                "source": "engine_logs",
                "engine_container": engine_container,
                "error": txt.strip() if txt else "empty logs",
                "line": None,
                "recent": False,
            }

        last_line = None
        last_ts = None

        for raw in txt.splitlines():
            line = self._strip_docker_prefix(raw)
            if not self._RE_STREAM_START.search(line):
                continue
            last_line = line.strip()
            m = re.match(r"^(?P<ts>\d{4}-\d{2}-\d{2}\s+\d{2}:\d{2}:\d{2},\d{3})\s+", last_line)
            if m:
                last_ts = self._parse_sched_ts(m.group("ts"))

        if not last_line:
            return {
                "ok": True,
                "source": "engine_logs",
                "engine_container": engine_container,
                "line": None,
                "recent": False,
            }

        recent = False
        age_s = None
        if last_ts:
            try:
                now_local = dt.datetime.now()
                age_s = int((now_local - last_ts).total_seconds())
                recent = age_s >= 0 and age_s <= int(recent_window_s)
            except Exception:
                recent = False

        return {
            "ok": True,
            "source": "engine_logs",
            "engine_container": engine_container,
            "line": last_line,
            "ts": last_ts.isoformat() if last_ts else None,
            "age_s": age_s,
            "recent": recent,
            "recent_window_s": int(recent_window_s),
        }


---
# src/azursmartmix_control/icecast_client.py
---

from __future__ import annotations

from typing import Any, Dict, Optional

import httpx


class IcecastClient:
    """Read-only Icecast status client (best-effort).

    Default endpoint: /status-json.xsl
    We extract the source matching the configured mount and return:
    - title (if present)
    - artist (if present)
    - listeners, bitrate, server_name, etc. when available
    """

    def __init__(self, scheme: str, host: str, port: int, status_path: str, mount: str) -> None:
        self.scheme = scheme or "http"
        self.host = host
        self.port = int(port)
        self.status_path = status_path or "/status-json.xsl"
        self.mount = mount if mount.startswith("/") else f"/{mount}"
        self.timeout = httpx.Timeout(2.5, connect=1.5)

    def _base(self) -> str:
        return f"{self.scheme}://{self.host}:{self.port}"

    async def fetch_status(self) -> Dict[str, Any]:
        url = f"{self._base()}{self.status_path}"
        async with httpx.AsyncClient(timeout=self.timeout) as client:
            r = await client.get(url)
            r.raise_for_status()
            # Icecast status-json is usually JSON despite .xsl
            try:
                return r.json()
            except Exception:
                return {"raw_text": r.text}

    @staticmethod
    def _iter_sources(payload: Dict[str, Any]):
        icestats = (payload or {}).get("icestats") or {}
        src = icestats.get("source")
        if src is None:
            return []
        if isinstance(src, list):
            return src
        return [src] if isinstance(src, dict) else []

    async def now_playing(self) -> Dict[str, Any]:
        try:
            payload = await self.fetch_status()
        except Exception as e:
            return {
                "ok": False,
                "source": "icecast",
                "error": str(e),
                "mount": self.mount,
            }

        sources = self._iter_sources(payload)
        match = None
        for s in sources:
            # Icecast uses "listenurl" and/or "mount" depending on version/config
            mount = s.get("mount") or None
            if mount is None:
                listenurl = s.get("listenurl") or ""
                if listenurl.endswith(self.mount):
                    match = s
                    break
            else:
                if str(mount) == self.mount:
                    match = s
                    break

        if match is None:
            return {
                "ok": False,
                "source": "icecast",
                "error": "mount not found in status",
                "mount": self.mount,
                "available": [
                    (s.get("mount") or s.get("listenurl") or "unknown") for s in sources
                ],
            }

        # "title" is what many sources set (often "Artist - Track")
        title = match.get("title") or match.get("yp_currently_playing") or None
        artist = match.get("artist") or None

        return {
            "ok": True,
            "source": "icecast",
            "mount": self.mount,
            "title": title,
            "artist": artist,
            "listeners": match.get("listeners"),
            "listener_peak": match.get("listener_peak"),
            "bitrate": match.get("bitrate"),
            "server_name": match.get("server_name"),
            "genre": match.get("genre"),
            "raw": match,
        }


---
# src/azursmartmix_control/main.py
---

from __future__ import annotations

import logging

from pythonjsonlogger import jsonlogger
from fastapi import FastAPI
from nicegui import app, ui

from azursmartmix_control.config import get_settings
from azursmartmix_control.api import create_api
from azursmartmix_control.ui import ControlUI


def setup_logging() -> None:
    logger = logging.getLogger()
    logger.setLevel(logging.INFO)
    handler = logging.StreamHandler()
    formatter = jsonlogger.JsonFormatter("%(asctime)s %(levelname)s %(name)s %(message)s")
    handler.setFormatter(formatter)
    logger.handlers = [handler]


def main() -> int:
    setup_logging()
    settings = get_settings()

    api_app: FastAPI = create_api(settings)

    # Mount FastAPI under /api so NiceGUI and API share one server/port
    app.mount(settings.api_prefix, api_app)

    # Build NiceGUI UI
    ui_builder = ControlUI(settings)
    ui_builder.build()

    ui.run(
        host=settings.ui_host,
        port=settings.ui_port,
        reload=False,
        title="AzurSmartMix Control",
        show=False,
    )
    return 0


if __name__ == "__main__":
    raise SystemExit(main())


---
# src/azursmartmix_control/scheduler_client.py
---

from __future__ import annotations

from typing import Any, Dict, Optional

import httpx


class SchedulerClient:
    """Proxy client to AzurSmartMix scheduler API.

    v1: scheduler has /health and /next.
    Now-playing endpoints are NOT assumed to exist.
    If you later add one, set env SCHED_NOW_ENDPOINT (e.g. "/now").
    """

    def __init__(self, base_url: str, now_endpoint: Optional[str] = None) -> None:
        self.base_url = base_url.rstrip("/")
        self.timeout = httpx.Timeout(2.5, connect=1.5)
        self.now_endpoint = (now_endpoint or "").strip() or None

    async def health(self) -> Dict[str, Any]:
        async with httpx.AsyncClient(timeout=self.timeout) as client:
            r = await client.get(f"{self.base_url}/health")
            r.raise_for_status()
            data = self._safe_json(r)
            return data if isinstance(data, dict) else {"ok": True, "raw": data}

    async def now_playing(self) -> Dict[str, Any]:
        """Now playing via scheduler IF configured.

        By default returns a note (no probes, no log spam).
        """
        if not self.now_endpoint:
            return {
                "source": None,
                "data": {"note": "Scheduler now-playing endpoint not configured (v1)."},
            }

        data = await self._try_get_json(self.now_endpoint)
        if data is None:
            return {
                "source": self.now_endpoint,
                "data": {"note": "Configured scheduler now endpoint returned error/404."},
            }
        return {"source": self.now_endpoint, "data": data}

    async def upcoming(self, n: int = 10) -> Dict[str, Any]:
        """Best-effort upcoming queue."""
        # Prefer /next?n=...
        data = await self._try_get_json(f"/next?n={n}")
        if data is not None:
            return {"source": f"/next?n={n}", "data": data}

        # Fallback /next10 style
        data = await self._try_get_json(f"/next{n}")
        if data is not None:
            return {"source": f"/next{n}", "data": data}

        # Minimal fallback /next1
        data = await self._try_get_json("/next1")
        if data is not None:
            return {"source": "/next1", "data": data}

        return {"source": None, "data": {"note": "No upcoming endpoint found on scheduler."}}

    async def _try_get_json(self, path: str) -> Optional[Any]:
        p = path if path.startswith("/") else f"/{path}"
        async with httpx.AsyncClient(timeout=self.timeout) as client:
            try:
                r = await client.get(f"{self.base_url}{p}")
                if r.status_code >= 400:
                    return None
                return self._safe_json(r)
            except Exception:
                return None

    @staticmethod
    def _safe_json(r: httpx.Response) -> Any:
        ct = (r.headers.get("content-type") or "").lower()
        if "application/json" in ct:
            try:
                return r.json()
            except Exception:
                return {"raw_text": r.text}
        txt = r.text.strip()
        return {"raw_text": txt} if txt else {}


---
# src/azursmartmix_control/ui.py
---

from __future__ import annotations

from typing import Any, Dict, List, Tuple

import html
import re

import httpx
from nicegui import ui

from azursmartmix_control.config import Settings


AZURA_CSS = r"""
:root{
  --az-blue: #1e88e5;
  --az-blue-dark: #1565c0;
  --az-bg: #1f242d;
  --az-card: #262c37;
  --az-card2: #2b3340;
  --az-border: rgba(255,255,255,.08);
  --az-text: rgba(255,255,255,.92);
  --az-muted: rgba(255,255,255,.65);
  --az-green: #22c55e;
  --az-red: #ef4444;
  --az-orange: #f59e0b;
  --az-cyan: #22d3ee;
  --az-violet: #a78bfa;
  --az-shadow: 0 10px 30px rgba(0,0,0,.25);
  --az-radius: 10px;
  --az-font: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif;
  --az-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  --wrap-max: 1860px;
  --grid-gap: 18px;
}

html, body { background: var(--az-bg) !important; color: var(--az-text) !important; font-family: var(--az-font) !important; }
.q-page-container, .q-layout, .q-page { background: var(--az-bg) !important; }
.q-card, .q-table__container, .q-menu, .q-dialog__inner, .q-drawer { background: transparent !important; }

.q-tab-panels,
.q-tab-panel,
.q-panel,
.q-panel-parent,
.q-tabs,
.q-tabs__content,
.q-tab-panels .q-panel,
.q-tab-panels .q-panel-parent {
  background: transparent !important;
}

.q-html,
.q-html * {
  background: transparent !important;
}

.az-topbar{
  background: linear-gradient(0deg, var(--az-blue) 0%, var(--az-blue-dark) 100%) !important;
  color: white !important;
  border-bottom: 1px solid rgba(255,255,255,.15);
  box-shadow: var(--az-shadow);
}
.az-topbar .az-brand { font-weight: 900; }
.az-topbar .az-sub { opacity: .85; font-weight: 600; }

.az-wrap{ width:100%; max-width: var(--wrap-max); margin: 0 auto; padding: 18px 18px 28px 18px; }
.az-grid{ display:grid; grid-template-columns: 1fr 1fr; gap: var(--grid-gap); }
@media (max-width: 1200px){ .az-grid{ grid-template-columns: 1fr; } }

.az-card{
  background: var(--az-card) !important;
  border: 1px solid var(--az-border);
  border-radius: var(--az-radius);
  box-shadow: var(--az-shadow);
  overflow: hidden;
  min-width: 520px;
}
@media (max-width: 1200px){ .az-card{ min-width: unset; } }

.az-card-h{
  background: var(--az-blue) !important;
  color: white !important;
  padding: 12px 14px;
  font-weight: 900;
  display:flex; align-items:center; justify-content:space-between;
}
.az-card-b{ padding: 14px; background: linear-gradient(180deg, var(--az-card2), var(--az-card)); }

.az-badge{
  display:inline-flex; align-items:center; gap:8px;
  padding:6px 10px; border-radius:999px;
  font-weight:900; font-size:12px;
  border:1px solid var(--az-border);
  background: rgba(255,255,255,.05);
}
.az-dot{ width:10px; height:10px; border-radius:999px; display:inline-block; }
.az-dot.ok{ background: var(--az-green); }
.az-dot.err{ background: var(--az-red); }
.az-dot.warn{ background: var(--az-orange); }

.az-actions .q-btn{ border-radius: 10px !important; font-weight: 900 !important; text-transform:none !important; }
.az-actions .q-btn--outline{ border:1px solid rgba(255,255,255,.55) !important; color:white !important; }

.az-list{ display:flex; flex-direction:column; gap:8px; }
.az-item{ padding: 10px 12px; border-radius: 10px; border: 1px solid var(--az-border); background: rgba(255,255,255,.04); }
.az-item .idx{ display:inline-block; min-width:24px; font-weight:950; color: rgba(255,255,255,.75); }
.az-item .txt{ font-weight:650; }

.rt-grid{ display:grid; grid-template-columns: 1fr 1fr; gap: 14px; }
@media (max-width: 900px){ .rt-grid{ grid-template-columns: 1fr; } }

.rt-box{
  border: 1px solid var(--az-border);
  border-radius: 10px;
  background: rgba(0,0,0,.10);
  overflow: hidden;
}
.rt-box-h{
  padding: 10px 12px;
  font-weight: 900;
  border-bottom: 1px solid rgba(255,255,255,.08);
  color: rgba(255,255,255,.92);
}
.rt-table{ width: 100%; border-collapse: collapse; font-size: 13px; }
.rt-table tr td{
  padding: 8px 12px;
  border-bottom: 1px solid rgba(255,255,255,.06);
  vertical-align: top;
}
.rt-table tr:last-child td{ border-bottom: none; }
.rt-k{ width: 140px; color: var(--az-muted); }
.rt-v{ color: rgba(255,255,255,.92); font-family: var(--az-mono); word-break: break-word; }

.env-toolbar{ display:flex; gap:10px; align-items:center; margin-bottom: 10px; }
.env-search input{ font-family: var(--az-mono) !important; }
.env-frame{
  max-height: 360px;
  overflow-y: auto;
  padding-right: 6px;
  border: 1px solid var(--az-border);
  border-radius: 10px;
  background: rgba(0,0,0,.12);
}
.env-row{
  display:grid;
  grid-template-columns: 260px 1fr;
  gap: 10px;
  padding: 8px 10px;
  border-bottom: 1px solid rgba(255,255,255,.06);
}
.env-row:last-child{ border-bottom: none; }
.env-k{
  font-family: var(--az-mono);
  font-size: 12px;
  color: rgba(255,255,255,.80);
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}
.env-v{
  font-family: var(--az-mono);
  font-size: 12px;
  color: rgba(255,255,255,.92);
  word-break: break-word;
}
.env-row:hover{ background: rgba(255,255,255,.05); }

.env-frame::-webkit-scrollbar{ width: 10px; }
.env-frame::-webkit-scrollbar-track{ background: rgba(255,255,255,.06); border-radius: 10px; }
.env-frame::-webkit-scrollbar-thumb{ background: rgba(255,255,255,.22); border-radius: 10px; }
.env-frame::-webkit-scrollbar-thumb:hover{ background: rgba(255,255,255,.34); }

.console-frame{
  height: 420px;
  overflow: auto;
  border: 1px solid var(--az-border);
  border-radius: 10px;
  background: rgba(0,0,0,.55) !important;
  padding: 10px 12px;
}
.console-frame, .console-frame * { background: transparent !important; }
.console-frame { background: rgba(0,0,0,.55) !important; }
.console-content{
  font-family: var(--az-mono) !important;
  font-size: 12px !important;
  line-height: 1.35 !important;
  color: rgba(255,255,255,.86) !important;
  white-space: pre-wrap !important;
  word-break: break-word !important;
  margin: 0 !important;
  padding: 0 !important;
}

.t-dim{ color: rgba(255,255,255,.45) !important; }
.t-info{ color: rgba(56, 189, 248, .95) !important; }
.t-warn{ color: rgba(245, 158, 11, .95) !important; }
.t-err{  color: rgba(239, 68, 68, .95) !important; }
.t-ok{   color: rgba(34, 197, 94, .95) !important; }
.t-vio{  color: rgba(167, 139, 250, .95) !important; }
.t-cyan{ color: rgba(34, 211, 238, .95) !important; }
.t-bold{ font-weight: 900 !important; }

.az-player{
  width: 100%;
  margin-top: 10px;
  padding: 10px 10px;
  border-radius: 12px;
  border: 1px solid var(--az-border);
  background: rgba(0,0,0,.22);
}
.az-player audio{
  width: 100%;
  height: 42px;
  filter: invert(1) hue-rotate(180deg) saturate(1.2);
  opacity: 0.95;
}
.az-player .hint{
  margin-top: 8px;
  font-size: 12px;
  color: rgba(255,255,255,.65);
  font-family: var(--az-mono);
}

/* meta rows */
.np-meta{
  margin-top: 8px;
  display:flex;
  flex-direction:column;
  gap: 6px;
}
.np-line{
  font-family: var(--az-mono);
  font-size: 12px;
  color: rgba(255,255,255,.80);
}
.np-k{ color: rgba(255,255,255,.55); }
.np-v{ color: rgba(255,255,255,.92); font-weight: 800; }
.np-pill{
  display:inline-flex; align-items:center; gap:8px;
  padding: 5px 10px;
  border-radius: 999px;
  border:1px solid var(--az-border);
  background: rgba(255,255,255,.05);
}
"""

AZURA_JS = r"""
document.addEventListener('click', (ev) => {
  const el = ev.target.closest('[data-copy]');
  if (!el) return;
  const txt = el.getAttribute('data-copy') || el.textContent || '';
  if (!txt) return;
  navigator.clipboard.writeText(txt).catch(()=>{});
});
"""


class ControlUI:
    def __init__(self, settings: Settings) -> None:
        self.settings = settings
        self.api_base = settings.api_prefix.rstrip("/")
        self.timeout = httpx.Timeout(2.5, connect=1.5)
        self._timer = None

        self._docker_badge = None
        self._rt_engine_tbl = None
        self._rt_sched_tbl = None

        self._now_title = None
        self._now_meta = None
        self._now_player = None

        self._up_list_container = None

        self._env_search = None
        self._env_frame = None
        self._env_rows: List[Tuple[str, str]] = []

        self._log_html_engine = None
        self._log_html_sched = None

    def _stream_public_url(self) -> str:
        public = getattr(self.settings, "icecast_public_url", "") or ""
        public = str(public).strip()
        if public:
            return public.rstrip("/")
        scheme = getattr(self.settings, "icecast_scheme", "http")
        host = getattr(self.settings, "icecast_host", "localhost")
        port = getattr(self.settings, "icecast_port", 8000)
        mount = getattr(self.settings, "icecast_mount", "/")
        if not str(mount).startswith("/"):
            mount = "/" + str(mount)
        return f"{scheme}://{host}:{port}{mount}"

    def build(self) -> None:
        ui.add_head_html(f"<style>{AZURA_CSS}</style>")
        ui.add_head_html(f"<script>{AZURA_JS}</script>")
        ui.page_title("AzurSmartMix Control")

        with ui.header().classes("az-topbar items-center justify-between"):
            with ui.row().classes("items-center gap-3"):
                ui.label("azuracast").classes("az-brand text-xl")
                ui.label("AzurSmartMix Control").classes("az-sub text-sm")
            with ui.row().classes("items-center gap-2 az-actions"):
                ui.button("Refresh", on_click=self.refresh_all).props("unelevated color=white text-color=primary")
                ui.button("Auto 5s", on_click=self.enable_autorefresh).props("outline")
                ui.button("Stop", on_click=self.disable_autorefresh).props("outline")

        with ui.element("div").classes("az-wrap"):
            with ui.element("div").classes("az-grid"):
                self._card_runtime()
                self._card_env()
                self._card_now()
                self._card_upcoming()

            with ui.element("div").classes("az-grid").style("margin-top: 16px;"):
                self._card_logs()

        ui.timer(0.1, self.refresh_all, once=True)

    def _card_runtime(self) -> None:
        with ui.element("div").classes("az-card"):
            with ui.element("div").classes("az-card-h"):
                ui.label("Runtime Status")
                self._docker_badge = ui.html(
                    '<span class="az-badge"><span class="az-dot warn"></span><span>Docker: …</span></span>'
                )
            with ui.element("div").classes("az-card-b"):
                with ui.element("div").classes("rt-grid"):
                    self._rt_engine_tbl = self._runtime_box("Engine")
                    self._rt_sched_tbl = self._runtime_box("Scheduler")

    def _runtime_box(self, title: str):
        with ui.element("div").classes("rt-box"):
            ui.label(title).classes("rt-box-h")
            tbl = ui.html(self._runtime_table_html({}))
            return tbl

    def _runtime_table_html(self, data: Dict[str, Any]) -> str:
        def v(key: str, default: str = "—") -> str:
            raw = data.get(key)
            if raw is None or raw == "":
                raw = default
            return html.escape(str(raw))

        rows = [
            ("name", v("name")),
            ("image", v("image")),
            ("status", v("status")),
            ("health", v("health", "-")),
            ("uptime", v("uptime", "-")),
        ]
        tr = "".join(
            f'<tr><td class="rt-k">{html.escape(k)}</td><td class="rt-v" data-copy="{val}">{val}</td></tr>'
            for k, val in rows
        )
        return f'<table class="rt-table">{tr}</table>'

    def _card_env(self) -> None:
        with ui.element("div").classes("az-card"):
            with ui.element("div").classes("az-card-h"):
                ui.label("Engine env (docker-compose)")
                ui.label(self.settings.compose_service_engine).classes("text-xs").style("opacity:.85;")
            with ui.element("div").classes("az-card-b"):
                with ui.element("div").classes("env-toolbar"):
                    self._env_search = ui.input(placeholder="Filter (key/value)…").classes("env-search").props("dense outlined")
                    ui.button("Clear", on_click=self._env_clear_filter).props("outline")
                self._env_frame = ui.element("div").classes("env-frame")

    def _card_now(self) -> None:
        stream_url = self._stream_public_url()
        mount = getattr(self.settings, "icecast_mount", "/gst-test.mp3")
        with ui.element("div").classes("az-card"):
            with ui.element("div").classes("az-card-h"):
                ui.label("Now Playing")
                ui.label(str(mount)).classes("text-xs").style("opacity:.85;")
            with ui.element("div").classes("az-card-b"):
                self._now_title = ui.label("—").classes("text-xl").style("font-weight: 950; margin: 2px 0 0 0;")
                self._now_meta = ui.html(self._now_meta_html({}))
                self._now_player = ui.html(self._player_html(stream_url))
                ui.label("Sources: Icecast(observed) + scheduler NEXT + engine STREAM_START hint").style(
                    "font-size: 12px; opacity:.7; margin-top: 10px;"
                )

    def _now_meta_html(self, now: Dict[str, Any]) -> str:
        now_mode = now.get("now_mode") or "observed"

        playlist_eff = now.get("playlist_effective")
        pl_txt = html.escape(str(playlist_eff)) if playlist_eff else "—"

        predicted = now.get("predicted_next") if isinstance(now.get("predicted_next"), dict) else None
        pred_title = "—"
        pred_pl = "—"
        if predicted:
            pred_title = html.escape(str(predicted.get("title_display") or predicted.get("title") or "—"))
            pred_pl = html.escape(str(predicted.get("playlist") or "—"))

        ss = now.get("engine_stream_start") if isinstance(now.get("engine_stream_start"), dict) else None
        hint = ""
        if ss and ss.get("ok") and ss.get("recent"):
            age = ss.get("age_s")
            age_txt = f"{age}s" if isinstance(age, int) else "recent"
            hint = f'<span class="np-pill"><span class="t-ok t-bold">STREAM_START</span><span class="t-dim">({html.escape(age_txt)})</span></span>'
        elif ss and ss.get("ok") and ss.get("line"):
            age = ss.get("age_s")
            age_txt = f"{age}s" if isinstance(age, int) else ""
            hint = f'<span class="np-pill"><span class="t-dim">last STREAM_START</span><span class="t-dim">{html.escape(age_txt)}</span></span>'

        obs = ""
        if now_mode == "optimistic":
            title_obs = html.escape(str(now.get("title_observed") or "—"))
            pl_obs = html.escape(str(now.get("playlist_observed") or "—"))
            obs = (
                f'<div class="np-line"><span class="np-k">observed:</span> '
                f'<span class="t-dim" data-copy="{title_obs}">{title_obs}</span> '
                f'<span class="t-dim">|</span> <span class="t-dim" data-copy="{pl_obs}">{pl_obs}</span></div>'
            )

        return (
            '<div class="np-meta">'
            f'  <div class="np-line"><span class="np-k">playlist:</span> <span class="np-v" data-copy="{pl_txt}">{pl_txt}</span></div>'
            f'  <div class="np-line"><span class="np-k">next(pred):</span> <span class="np-v" data-copy="{pred_title}">{pred_title}</span>'
            f'    <span class="t-dim">|</span> <span class="np-k">pl:</span> <span class="np-v" data-copy="{pred_pl}">{pred_pl}</span></div>'
            f'  {obs}'
            f'  <div class="np-line">{hint}</div>'
            '</div>'
        )

    def _player_html(self, url: str) -> str:
        u = html.escape(url)
        return (
            f'<div class="az-player">'
            f'  <audio controls preload="none" crossorigin="anonymous">'
            f'    <source src="{u}" type="audio/mpeg" />'
            f'  </audio>'
            f'  <div class="hint" data-copy="{u}">{u}</div>'
            f'</div>'
        )

    def _card_upcoming(self) -> None:
        with ui.element("div").classes("az-card"):
            with ui.element("div").classes("az-card-h"):
                ui.label("Upcoming")
                ui.label("from scheduler NEXT log").classes("text-xs").style("opacity:.85;")
            with ui.element("div").classes("az-card-b"):
                self._up_list_container = ui.element("div").classes("az-list")

    def _card_logs(self) -> None:
        with ui.element("div").classes("az-card").style("grid-column: 1 / -1;"):
            with ui.element("div").classes("az-card-h"):
                ui.label("Logs")
                ui.label("tail=200").classes("text-xs").style("opacity:.85;")
            with ui.element("div").classes("az-card-b"):
                tabs = ui.tabs().classes("w-full")
                t_engine = ui.tab("engine")
                t_sched = ui.tab("scheduler")

                with ui.tab_panels(tabs, value=t_engine).classes("w-full"):
                    with ui.tab_panel(t_engine):
                        with ui.element("div").classes("console-frame").style("background: rgba(0,0,0,.55) !important;"):
                            self._log_html_engine = ui.html('<div class="console-content">—</div>')
                    with ui.tab_panel(t_sched):
                        with ui.element("div").classes("console-frame").style("background: rgba(0,0,0,.55) !important;"):
                            self._log_html_sched = ui.html('<div class="console-content">—</div>')

    async def _get_json(self, path: str) -> Dict[str, Any]:
        url = f"http://127.0.0.1:{self.settings.ui_port}{self.api_base}{path}"
        async with httpx.AsyncClient(timeout=self.timeout) as client:
            r = await client.get(url)
            r.raise_for_status()
            data = r.json()
            return data if isinstance(data, dict) else {"data": data}

    async def _get_text(self, path: str) -> str:
        url = f"http://127.0.0.1:{self.settings.ui_port}{self.api_base}{path}"
        async with httpx.AsyncClient(timeout=self.timeout) as client:
            r = await client.get(url)
            r.raise_for_status()
            return r.text

    _re_level = re.compile(r"\b(INFO|WARN|WARNING|ERROR|CRITICAL|DEBUG)\b")
    _re_engine_tag = re.compile(r"\bazurmixd\.engine\b")
    _re_sched_tag = re.compile(r"\bazurmixd\.scheduler\b")
    _re_preprocess = re.compile(r"\bpreprocess:\b")
    _re_bridge = re.compile(r"\bbridgeplan:\b")
    _re_aft = re.compile(r"\bAFT#\d+\b")
    _re_icecast = re.compile(r"\b(Icecast|ICECAST|/status-json\.xsl|mount|listeners?)\b", re.IGNORECASE)
    _re_uri = re.compile(r"\b(file:///[^ ]+)\b")
    _re_stream_start = re.compile(r"\bBUS\s+STREAM_START\b", re.IGNORECASE)

    def _highlight_logs_html(self, text: str) -> str:
        esc = html.escape(text)

        def repl_level(m: re.Match) -> str:
            lvl = m.group(1)
            cls = "t-info"
            if lvl in ("WARN", "WARNING"):
                cls = "t-warn"
            elif lvl in ("ERROR", "CRITICAL"):
                cls = "t-err"
            elif lvl == "DEBUG":
                cls = "t-dim"
            return f'<span class="{cls} t-bold">{lvl}</span>'

        esc = self._re_level.sub(repl_level, esc)
        esc = self._re_engine_tag.sub(r'<span class="t-cyan t-bold">azurmixd.engine</span>', esc)
        esc = self._re_sched_tag.sub(r'<span class="t-cyan t-bold">azurmixd.scheduler</span>', esc)
        esc = self._re_preprocess.sub(r'<span class="t-vio t-bold">preprocess:</span>', esc)
        esc = self._re_bridge.sub(r'<span class="t-vio">bridgeplan:</span>', esc)
        esc = self._re_aft.sub(lambda m: f'<span class="t-ok t-bold">{m.group(0)}</span>', esc)
        esc = self._re_icecast.sub(lambda m: f'<span class="t-cyan">{m.group(0)}</span>', esc)
        esc = self._re_stream_start.sub(lambda m: f'<span class="t-ok t-bold">{m.group(0)}</span>', esc)
        esc = self._re_uri.sub(r'<span class="t-dim">\1</span>', esc)

        return f'<div class="console-content">{esc}</div>'

    async def refresh_all(self) -> None:
        await self.refresh_runtime()
        await self.refresh_engine_env()
        await self.refresh_now()
        await self.refresh_upcoming()
        await self.refresh_logs()

    async def refresh_runtime(self) -> None:
        try:
            rt = await self._get_json("/panel/runtime")
        except Exception:
            self._set_docker_badge(ok=False, text="Docker: error")
            if self._rt_engine_tbl:
                self._rt_engine_tbl.set_content(self._runtime_table_html({"status": "error"}))
            if self._rt_sched_tbl:
                self._rt_sched_tbl.set_content(self._runtime_table_html({"status": "error"}))
            return

        docker_ok = bool(rt.get("docker_ping"))
        self._set_docker_badge(ok=docker_ok, text=f"Docker: {'OK' if docker_ok else 'DOWN'}")

        eng = rt.get("engine") or {}
        sch = rt.get("scheduler") or {}

        if self._rt_engine_tbl:
            self._rt_engine_tbl.set_content(self._runtime_table_html(eng))
        if self._rt_sched_tbl:
            self._rt_sched_tbl.set_content(self._runtime_table_html(sch))

    def _set_docker_badge(self, ok: bool, text: str) -> None:
        if self._docker_badge is None:
            return
        dot = "ok" if ok else "err"
        self._docker_badge.set_content(
            f'<span class="az-badge"><span class="az-dot {dot}"></span><span>{html.escape(text)}</span></span>'
        )

    async def refresh_engine_env(self) -> None:
        if self._env_frame is None:
            return
        try:
            data = await self._get_json("/panel/engine_env")
            env = data.get("environment") if isinstance(data, dict) else None
            if isinstance(env, dict):
                self._env_rows = [(k, str(env.get(k, ""))) for k in sorted(env.keys())]
            else:
                self._env_rows = [("error", str(data))]
        except Exception as e:
            self._env_rows = [("error", str(e))]
        self._render_env()

    def _env_clear_filter(self) -> None:
        if self._env_search:
            self._env_search.set_value("")
        self._render_env()

    def _render_env(self) -> None:
        if self._env_frame is None:
            return
        q = ""
        if self._env_search:
            q = (self._env_search.value or "").strip().lower()

        rows = self._env_rows
        if q:
            rows = [(k, v) for (k, v) in rows if q in k.lower() or q in v.lower()]

        self._env_frame.clear()
        with self._env_frame:
            if not rows:
                ui.html('<div style="padding:10px; opacity:.7;">—</div>')
                return
            for k, v in rows:
                k_e = html.escape(k)
                v_e = html.escape(v)
                ui.html(
                    f'<div class="env-row">'
                    f'  <div class="env-k" data-copy="{k_e}">{k_e}</div>'
                    f'  <div class="env-v" data-copy="{v_e}">{v_e}</div>'
                    f'</div>'
                )

    async def refresh_now(self) -> None:
        try:
            now = await self._get_json("/panel/now")
            title = now.get("title_effective") or now.get("title_observed") or "—"
            self._now_title.set_text(title)
            if self._now_meta:
                self._now_meta.set_content(self._now_meta_html(now if isinstance(now, dict) else {}))
        except Exception:
            self._now_title.set_text("—")
            if self._now_meta:
                self._now_meta.set_content(self._now_meta_html({}))

    async def refresh_upcoming(self) -> None:
        if self._up_list_container is None:
            return
        try:
            up = await self._get_json("/panel/upcoming?n=10")
            items = up.get("upcoming") or []
            if not isinstance(items, list):
                items = []
        except Exception:
            items = []

        self._up_list_container.clear()
        with self._up_list_container:
            if not items:
                ui.html('<div style="opacity:.7; font-size: 12px;">—</div>')
                return
            for i, it in enumerate(items, start=1):
                if not isinstance(it, dict):
                    continue
                title = str(it.get("title_display") or it.get("title") or "—")
                playlist = str(it.get("playlist") or "—")
                ts = str(it.get("ts") or "")

                title_e = html.escape(title)
                playlist_e = html.escape(playlist)
                ts_e = html.escape(ts)
                tail = f' <span class="t-dim">[{ts_e}]</span>' if ts else ""
                ui.html(
                    f'<div class="az-item"><span class="idx">{i}.</span> '
                    f'<span class="txt" data-copy="{title_e}">{title_e}</span> '
                    f'<span class="t-dim">|</span> '
                    f'<span class="t-cyan t-bold" data-copy="{playlist_e}">{playlist_e}</span>'
                    f'{tail}'
                    f'</div>'
                )

    async def refresh_logs(self) -> None:
        try:
            eng = await self._get_text("/logs?service=engine&tail=200")
            if self._log_html_engine:
                self._log_html_engine.set_content(self._highlight_logs_html(eng))
        except Exception:
            if self._log_html_engine:
                self._log_html_engine.set_content('<div class="console-content">—</div>')

        try:
            sch = await self._get_text("/logs?service=scheduler&tail=200")
            if self._log_html_sched:
                self._log_html_sched.set_content(self._highlight_logs_html(sch))
        except Exception:
            if self._log_html_sched:
                self._log_html_sched.set_content('<div class="console-content">—</div>')

    def enable_autorefresh(self) -> None:
        if self._timer is not None:
            return
        self._timer = ui.timer(5.0, self.refresh_all)

    def disable_autorefresh(self) -> None:
        if self._timer is not None:
            self._timer.cancel()
        self._timer = None


---
# Estimation du nombre de tokens : 17639 tokens
